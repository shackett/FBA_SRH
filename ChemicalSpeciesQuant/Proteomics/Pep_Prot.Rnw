\documentclass[12pt]{article}
\usepackage[left=0.95in,top=0.95in,right=0.95in,bottom=0.95in,nohead]{geometry}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{wrapfig}	%in-line figures
\usepackage[numbers, super]{natbib}		%bibliography
%\usepackage{pslatex} 	%for times new roman
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{aurical}
\usepackage[scaled]{helvet}
\usepackage{multicol}

\Sexpr{opts_chunk$set(tidy=TRUE, message=FALSE)}
<<echo=FALSE,results='hide'>>=
options(width=80)
library(knitr)

setwd('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics')
load('20120807ProtPepMatrices.Rdata')
source("pep_library.R")
plotting_fxn()
matrix_fxn()
library(ggplot2)
library(flexclust)

@


\author{Sean R. Hackett}
\title{Peptides to Protein EM and analysis} 
\date{}

\begin{document}

\setlength{\parskip}{0.5mm}
\linespread{1}

\thispagestyle{empty}
\pagestyle{empty}

\maketitle


\section*{Data Processing}

\small

<<dataImp, cache=TRUE>>=

quality_frac <- 0.8
ICthreshold <- 2^15
#only consider peptides that match unambiguously to a single protein
unq_matches_only <- FALSE

lightIC[lightIC < ICthreshold] <- NA; heavyIC[heavyIC < ICthreshold] <- NA

good_samples <- rowSums(is.finite(PepMatrix) & !is.na(lightIC) & !is.na(heavyIC)) >= (length(PepMatrix[1,])*quality_frac)

#possible mappings between a protein and all matching peptides
mappingMat <- ProtPepMatrix[good_samples,]
nsharedpep <- table(rowSums(mappingMat))

if(unq_matches_only){
	good_samples[good_samples] <- good_samples[good_samples] & (rowSums(mappingMat) == 1)
	mappingMat <- ProtPepMatrix[good_samples,]
	}
mappingMat <- mappingMat[,colSums(mappingMat) != 0]

#the relative abundance of a peptide across conditions w.r.t a common reference
abundMat <- PepMatrix[good_samples,]
good_light <- lightIC[good_samples,]
good_heavy <- heavyIC[good_samples,]

#map measured peaks to unique peptide sequences

pepNames <- rownames(mappingMat)
unique_NameCorr <- sapply(pepNames, function(name){
	unlist(strsplit(name, "\\."))[1]
	})
unique_pepNames <- unique(unique_NameCorr)
unique_NameCorrCol <- sapply(unique_NameCorr, function(name){
	c(1:length(unique_pepNames))[name == unique_pepNames]
	})

pepToUniq <- matrix(0, nrow = length(pepNames), ncol = length(unique_pepNames))
rownames(pepToUniq) <- pepNames; colnames(pepToUniq) <- unique_pepNames
for(i in 1:length(pepNames)){
	pepToUniq[i,unique_NameCorrCol[i]] <- 1
	}
pepToUniq <- Matrix(pepToUniq)

#determine the expectation of the standard deviation as a heteroschedastic fxn of IC using p0.05 light v. p0.05 heavy

avgSignalSTD <- apply(cbind(heavyIC[,colnames(heavyIC) == "P0.05"], lightIC[,colnames(lightIC) == "P0.05"]), 1, mean)
logLight <- log2(lightIC[is.finite(avgSignalSTD),colnames(lightIC) == "P0.05"])
logHeavy <- log2(heavyIC[is.finite(avgSignalSTD),colnames(heavyIC) == "P0.05"])
avgSignalSTD <- avgSignalSTD[is.finite(avgSignalSTD)]
#remove this step to increase variance, since this factor isnt known in principle
logLight <- logLight + optimize(normFactor, c(-1, 1), logLight = logLight, logHeavy = logHeavy)$minimum

#variance of the replicate differences accounting for small sample (scaling factor of 2)
STDvar <- (logLight - logHeavy)^2*2
STDvar_fit <- lm(log2(STDvar) ~ log2(avgSignalSTD))$coef



@

\normalsize

\begin{figure}[h!]
<<nshare, dependson = "dataImp", echo = FALSE>>=
barplot(nsharedpep)
@
\caption{Number of proteins that a measured peptide matches}
\end{figure}

\begin{itemize}
\item Remove all peptides with more than \Sexpr{1 - quality_frac} fraction of missing data
\item Remove all peptides with less than \Sexpr{ICthreshold} ions measured
\item This results in \Sexpr{table(good_samples)[names(table(good_samples)) == TRUE]} peptides that are retained and \Sexpr{table(good_samples)[names(table(good_samples)) == FALSE]} peptides which are discarded.
\end{itemize}

In order to determine the expected variance of the relative abundance of a peptide($\mathbf{X}_{ic}$ about the relative abundance of its corresponding protein ($\mathbf{\Omega}_{kc}$), we assume that $\mathbf{X}_{ic} \sim N(\mathbf{\Omega}_{kc}, \sigma^{2}_{ic}$) with $E[\sigma^{2}_{ic}]$ being fitted either from residuals or replicates.

Fitting from replicates can be done because all of the samples are quantified with respect to a common reference p0.05, including an experimental sample of p0.05.  The difference between these  

\begin{figure}[h!]
<<repdiffplot1, dependson = "dataImp", echo = FALSE>>=
gplot.hexbin(hexbin(logLight, logHeavy, xbins = 200), colramp = rainbow)
@
\label{heavylightcomp}
\caption{Comparison of log$_{2}$p0.05$^{H}$ and log$_{2}$p0.05$^{L}$}
\end{figure}

<<repdiffplot2, dependson = "dataImp", label = "ICsdreg1", echo = FALSE, include = FALSE>>=
plot(log2(STDvar) ~ log2(avgSignalSTD), pch = 16, cex = 0.3)
abline(STDvar_fit, col = "RED")
@

<<repdiffplot3, dependson = "dataImp", label = "ICsdreg2", echo = FALSE, include = FALSE>>=
gplot.hexbin(hexbin(log2(avgSignalSTD), log2(STDvar), xbins = 80), colramp = rainbow)
@


\begin{figure}[h!]
\begin{center}
\subfloat[Linear regression]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg1.pdf}
}
\qquad
\subfloat[Bivariate histogram: residual variance is a decreasing function of signal strength]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg2.pdf}}
\end{center}
\label{repFitSD1}
\caption{$\epsilon^{2}$ versus average log$_{2}$ ion counts of the heavy and light peak}
\end{figure}





\small

<<EMsetup, dependson = "dataImp", cache = TRUE>>=

#calculate the expected sampling variance of the heavy-low diff for experimental measurement

lightHeavyCellmean <- sapply(c(1:length(heavyIC[,1]))[good_samples], function(row){
	mapply(FUN = function(a,b){
		if(!is.na(a) & !is.na(b)){mean(a, b)}else{NA}
		}, lightIC[row,], heavyIC[row,])
	})

fittedVar <- var_calc(lightHeavyCellmean, STDvar_fit)
fittedPrec <- fittedVar^-1

#for each unique peptide, combine the multiple ionization states to produce a single point estimate, using integrated likelihood

#set the precision of missing values to 0; equivalent to no impact, infinite variance

fittedPrec[t(is.na(abundMat))] <- 0
fittedPrec[is.na(fittedPrec)] <- 0
abundMat[t(fittedPrec) == 0] <- 0

n_p = length(unique_pepNames) #4042
n_prot <- length(mappingMat[1,])
n_pp = n_p + n_prot #4964
n_c = length(abundMat[1,]) #15

uniquePepMean <- matrix((((t(abundMat) * fittedPrec) %*% pepToUniq)/(fittedPrec %*% pepToUniq)), ncol = n_p, nrow = n_c)
uniquePepPrecision <- Matrix(fittedPrec %*% pepToUniq)
uniquePepMean[is.nan(uniquePepMean)] <- NA

#change mapping from peptides to unique peptides (averaging over ionization states)
unique_mappingMat <- as.matrix(t(pepToUniq) %*% mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)


#number of non-missing values for peptides
Nmissing_val <- table(rowSums(!is.na(t(uniquePepMean))))

uniquePepMean[is.na(uniquePepMean)] <- 0

#number of non-missing values for all peptides (before uniquenss combination)
Nmissing_val_all <- table(apply(is.finite(PepMatrix), 1, sum))

@

\begin{figure}[h!]
<<mvbarplot, dependson = "EMsetup", echo = FALSE>>=
barplot(table(apply(is.finite(PepMatrix), 1, sum)), col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val_all)) < ceiling(n_c * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val_all)) >= ceiling(n_c * quality_frac)))))
@
\caption{Distribution of non-missing values for all peptides.  Peptides with non-missing values over the cutoff are shown in orange}
\label{nonmissingvals}
\end{figure}

<<mvmat, dependson = "EMsetup", cache = TRUE>>=

#look at structure in the missing values
binPepMatrix <- ifelse(is.finite(lightIC), 1, 0)

pnonmissingOverSingles <- matrix(NA, ncol = length(binPepMatrix[1,]), nrow = length(binPepMatrix[1,]))
rownames(pnonmissingOverSingles) <- colnames(binPepMatrix); colnames(pnonmissingOverSingles) <- colnames(binPepMatrix)
pnonmissingOverTotal <- pnonmissingOverSingles
for(i in 1:length(pnonmissingOverSingles[1,])){
	for(j in 1:length(pnonmissingOverSingles[1,])){	
	pnonmissingOverTotal[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2)/length(binPepMatrix[,1])
  	pnonmissingOverSingles[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2) / sum(apply(binPepMatrix[,c(i, j)], 1, sum) > 0)
	}
}

@

<<missingOverlap1, dependson = "mvmat", label = "missingOverlap1", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverTotal, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

<<missingOverlap2, dependson = "mvmat", label = "missingOverlap2", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverSingles, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

\begin{figure}[h!]
\begin{center}
\subfloat[p(A $\cap$ B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap1}
}
\qquad
\subfloat[A $\cap$ B / max(A, B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap2.pdf}}
\end{center}
\label{repFitSD2}
\caption{Overlap of missing ascertained peptides across conditions}
\end{figure}

<<mvmat_red, dependson = "mvmat">>=
uq_ProtPepMatrix <- ProtPepMatrix[rowSums(ProtPepMatrix) == 1,]
uq_binPepMatrix <- binPepMatrix[rowSums(ProtPepMatrix) == 1,]

cond_peps <- t(((t(uq_binPepMatrix) %*% uq_ProtPepMatrix) != 0)*1)
cond_peps <- cond_peps[!(rowSums(cond_peps) %in% c(0, length(cond_peps[1,]))),]

blackOrange <- function (n){colorpanel(n, "black", "black", "orange")}

@

\begin{figure}[h!]
<<misval_HM, dependson = "mvmat_red", echo = FALSE, warning = FALSE>>=
man_dist <- function(x){dist(x, method = "manhattan")}
heatmap.2(cond_peps, Rowv = TRUE, Colv = FALSE, trace = "none", col=blackOrange(100), distfun = man_dist, cexRow = 0.1)
@
\caption{hierarchical clustering of proteins missing in a subset of conditions using manhattan distance}
\end{figure}

<<cluster_misval, dependson = "mvmat_red", cache = TRUE>>=

#kvals <- c(2:20)
#data_clust <- stepFlexclust(cond_peps, k = kvals, nrep=20, verbose=FALSE, FUN = kcca, family = kccaFamily(which = "kmedians"))


#WICSS <- sapply(1:length(kvals), function(k_num){
#	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
#	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
#	})
	
#k_clust_misVal <- kvals[WICSS/WICSS[1] < 0.4][1]
k_clust_misVal <- 5

mv_clust <- stepFlexclust(cond_peps, k = k_clust_misVal, nrep=100, verbose=FALSE, FUN = kcca, family = kccaFamily(which = "kmedians"))

clust_counts1 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)
clust_counts0 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)

for(kval in 1:k_clust_misVal){
	binsub <- cond_peps[mv_clust@cluster == kval,]
	clust_counts1[kval,] <- colSums(binsub)
	clust_counts0[kval,] <- length(binsub[,1]) - colSums(binsub)
	}
clust_ypos_adj <- matrix(5*rep(0:(k_clust_misVal-1), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_xpos <- matrix(rep(1:n_c, times = k_clust_misVal), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_num <- matrix(rep(1:(k_clust_misVal), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)

clust_plot_df <- data.frame(condition = c(c(clust_xpos), c(clust_xpos)), cluster_val = c(c(1 + clust_ypos_adj), c(clust_ypos_adj)),counts = c(c(clust_counts1), c(clust_counts0)), shape = as.factor(c(c(clust_num), c(clust_num))), medianoid = as.factor(c(c(mv_clust@centers), c(1 - mv_clust@centers))))

@

\begin{figure}[h!]
<<plot_missingvalClusters, dependson = "cluster_misval", echo = FALSE>>=
clust_plot <- ggplot(clust_plot_df, aes(x = condition, y = cluster_val, size = counts, color = medianoid))
clust_plot <- clust_plot + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
clust_plot + geom_point()
@
\end{figure}

<<GSEA_prep, cache = TRUE>>=
library(GSEABase)
library(org.Sc.sgd.db)

frame = toTable(org.Sc.sgdGO)

goframeData = data.frame(frame$go_id, frame$Evidence, frame$systematic_name)
goFrame=GOFrame(goframeData,organism="Saccharomyces cerevisiae")
goAllFrame=GOAllFrame(goFrame)
gsc <- GeneSetCollection(goAllFrame, setType = GOCollection())
@

<<perform_GSEA, dependson= c("GSEA_prep", "cluster_misval"), cache = TRUE>>=
library(methods)
library(GOstats)
library(GSEABase)
FDR = .05

#MF - molecular function, BP - biological process, CC cellular component
GSEA.test = function(genes, category) {
	universe = rownames(cond_peps)
	
	params <- GSEAGOHyperGParams(name="GSEA for Bar-Seq data",
		geneSetCollection=gsc,
		geneIds = genes,
		universeGeneIds = universe,
		ontology = category,
		pvalueCutoff = 1,
		conditional = FALSE,
		testDirection = "over")
	hyperGTest(params)
	}

sum_table <- NULL
for(kval in 1:k_clust_misVal){
	test <- names(mv_clust@cluster[mv_clust@cluster == kval])
	for(ont in c("MF", "BP", "CC")){
		go_sum <- summary(GSEA.test(test, ont))
		lowp <- go_sum[go_sum$Pvalue < 0.001,]
		if(length(lowp[,1]) != 0){
			colnames(lowp)[1] <- "GOID"
			sum_table <- rbind(sum_table, cbind(k = kval, category = ont, lowp))
			}
		}
	}
@

<<GSEAtable, dependson = "perform_GSEA", results = "asis", echo = FALSE>>=
library(xtable)
xtable(sum_table, digits = 5)
@


\clearpage
\normalsize
\section*{Going from peptides to proteins via expectation-maximization}

When using relative variation in peptides to predict variation in protein abundance we need to deal with two factors
\begin{itemize}
\item If a peptide maps to multiple proteins, it should be attributed to a protein (thereby adding signal) to the extent that its pattern matches the pattern from other peptides.
\item Some peptides won't conform to the trends of their protein because they may be the non-covalently modified complement of a set of unascertained modified peptides.  These peptides shouldn't inform the general protein trend, and may be interesting to analyze in isolation.
\end{itemize}sum_list

\subsection*{Algorithm structure}

\begin{itemize}
\item[\textbf{X}:] [I $\cdot$ C] Data matrix: Input MS data of the relative abundance of each peptide across C conditions
\item[\textbf{M}:] [I $\cdot$ J] Possible mappings between peptides (I) and proteins (J)
\item[$\mathbf{\Theta}$:] [I $\cdot$ K] Responsibility matrix: prob that peptide i belongs to protein j or shows a divergent trend which should be described separately.  K = I + J
\item[$\mathbf{\Omega}$:] [K $\cdot$ C] Point estimate for each species$\cdot$condition.
\item[$\sigma^{2}$:] [I] Fitted variance relative to peptide IC.
\end{itemize}

\begin{align}
p(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &\propto \prod_{i}^{I}\prod_{c}^{C} \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i}) \cdot \mathbf{\Theta}p(\mathbf{\Theta})\notag\\
\textit{l}(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &= \sum_{i}^{I}\sum_{c}^{C} \textit{ln}\left( \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i})\right)\notag\\
+ \sum_{i}^{I}\sum_{k}^{K}\mathbf{\Theta_{ik}}p(\mathbf{\Theta_{ik}})
\end{align}


\subsection{Updating $\mathbf{\Theta}$}

\begin{align}
\mathbf{\Theta}_{ik} \sim \frac{\textbf{N}(\mathbf{\Omega}_{kC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ik})}{\sum_{b = 1}^{K}\textbf{N}(\mathbf{\Omega}_{bC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ib})}
\end{align}

\subsection{Updating $\mathbf{\Omega}$}

$\tau_{y} = \prod_{z \neq y}^{Y}\sigma^{2}_{z}$

\begin{align}
\mathbf{\Omega}_{kc} \sim \mbox{\Large \textbf{N}}\left(\mu = \frac{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\textbf{X}_{ic}\tau_{i}}{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\tau_{i}}, \sigma^{2} =  \left(\sum_{i = 1}^{I}\frac{\mathbf{\Theta}_{ik}}{\sigma^{2}_{i}}\right)^{-1} \right)
\end{align}

\subsection*{Algorithm Implementation}

\scriptsize

<<EMprep, dependson = "dataImp", cache = TRUE, warning = FALSE>>=
prerun_fixed_mat <- TRUE

### Initalization ###

prior_bound <- 0.9999
prior_p_div <- exp(-1*qchisq(prior_bound, n_c))

#if a putative protein only has component peptides which are matched to other proteins than penalize any assignment to it by the supremum of the mixing fraction

#number of shared peptides per protein
pepshared <- colSums(unique_mappingMat[c(1:n_p)[rowSums(unique_mappingMat) > 1],])
#total peptides per protein
peptotal <- colSums(unique_mappingMat)
ambigprots <- c(1:n_prot)[pepshared == peptotal]



tmp <- Matrix(diag(rep(prior_p_div, times = n_p))); colnames(tmp) <- paste(unique_pepNames, "divergent", sep = "_")
mixing_fract <- unique_mappingMat * (1/(t(t((1-prior_p_div)^-1*rowSums(unique_mappingMat)))) %*% rep(1, n_prot))
mixing_fract <- cBind(mixing_fract, tmp)
prior_mat_likadj <- unique_mappingMat/((1-prior_p_div)^-1)
prior_mat_likadj <- cBind(prior_mat_likadj, tmp)

tmp <- as.matrix(tmp)
tmp[!(tmp %in% c(0,1))] <- 1 
prior_mat_logical <- cbind(as.matrix(unique_mappingMat), tmp) 
prior_mat_logical <- prior_mat_logical == 1
prior_mat_sparse <- Matrix(prior_mat_logical)
#prior_mat_likadj2 <- prior_mat_likadj*prior_mat_sparse
prior_mat_likadj[prior_mat_sparse] <- log(prior_mat_likadj[prior_mat_sparse])
rm(tmp, prior_mat_logical)

#preprocess sparse data and precision matrices

if(prerun_fixed_mat == TRUE){
#lower processor usage, higher memory
sampleEst_list <- list()
samplePrec_list <- list()
for(c in 1:n_c){
	sampleEst_list[[c]] <- uniquePepMean[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse
	samplePrec_list[[c]] <- 0.5*(uniquePepPrecision[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse)
	}
	}
	
@

<<EMrun, dependson = "EMprep">>=	
			
### Iteration ###

if((unq_matches_only == TRUE & file.exists("EMoutputUnq.Rdata"))|(unq_matches_only == FALSE & file.exists("EMoutputDeg.Rdata"))){
	if(unq_matches_only == TRUE){
		load("EMoutputUnq.Rdata")
			}else{
			load("EMoutputDeg.Rdata")
			}
	}else{

whole_data_logL <- NULL
previous_it <- -Inf
continue_it <- TRUE

t <- 1
while(continue_it){
	
	#update protein abundances: using integrated likelihood
	#update protein means
	prot_abund = ((uniquePepMean*uniquePepPrecision) %*% mixing_fract)/(uniquePepPrecision %*% mixing_fract)
	prot_abund <- as.matrix(Matrix(prot_abund, sparse = FALSE))
	prot_abund[is.nan(prot_abund)] <- 0
	
	#update protein precision
	prot_prec <- uniquePepPrecision %*% mixing_fract
	
	#update mixing fract
	
	#evaluate the log-likelihood of sample abundances about the inferred protein abundances with a precision-specific to the signal strength of the samples
	if(prerun_fixed_mat == TRUE){
	sampleLik <- -1*((sampleEst_list[[1]] - (t(prot_abund[1,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec_list[[1]])
	for(c in 2:n_c){
		sampleLik <- sampleLik - ((sampleEst_list[[c]] - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec_list[[c]])
			}
		}else{
			for(c in 1:n_c){
				sampleEst <- uniquePepMean[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse
				samplePrec <- 0.5*(uniquePepPrecision[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse)
				if(c == 1){
					sampleLik <- -1*((sampleEst - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec)
					}else{
						sampleLik <- sampleLik - ((sampleEst - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec)
						}
				}
			}
	
	#correct for purely ambiguous proteins
	weight_store <- list()
	for(ap in ambigprots){
		tmp <- sampleLik[,ap][prior_mat_sparse[,ap]]
		weights <- exp(tmp)/sum(exp(tmp))
		weight_store[[ap]] <- weights
		sampleLik[,ap][prior_mat_sparse[,ap]] <- tmp + sapply(log((prior_p_div^-1 * weights)^-1), function(x){min(x, 0)})
		}
	
	#adjust for prior	
	sampleLik <- prior_mat_likadj + sampleLik
	
	#if an ambiguous protein has the highest likelihood (besides divergent peptides), than set the divergent peptide to log(prior_p_div) + penalty applied to sampleLIk
	
	if(!unq_matches_only){
	tmp <- sampleLik[,1:n_prot]; tmp[!prior_mat_sparse[,1:n_prot]] <- NA
	ambig_good_fit <- is.finite(apply(tmp[,ambigprots], 1, max, na.rm = TRUE)) & (apply(tmp[,ambigprots], 1, max, na.rm = TRUE) == apply(tmp, 1, max, na.rm = TRUE))
	good_fit_match <- ambigprots[apply(tmp[ambig_good_fit,ambigprots], 1, which.max)]
	
	div_adj2 <- sapply(1:length(good_fit_match), function(max_val){
		tmp2 <- weight_store[[good_fit_match[max_val]]]
		min(log((prior_p_div^-1 * tmp2[names(tmp2) == rownames(tmp)[ambig_good_fit][max_val]])^-1), 0)
		})
	
	for(repl in 1:length(good_fit_match)){
		sampleLik[c(1:n_p)[ambig_good_fit][repl], n_prot + c(1:n_p)[ambig_good_fit][repl]] <- sampleLik[c(1:n_p)[ambig_good_fit][repl], n_prot + c(1:n_p)[ambig_good_fit][repl]] + div_adj2[repl]
		}}
	
	sampleLik_NA <- sampleLik
	sampleLik_NA[!prior_mat_sparse] <- NA
	relLik <- sampleLik - apply(sampleLik_NA, 1, max_non_NA) %*% t(rep(1, times = n_pp)) * prior_mat_sparse
	relLik[prior_mat_sparse] <- exp(relLik[prior_mat_sparse])
	
	liksums <- apply(relLik, 1, sum)
	
	mixing_fract <- 1/liksums %*% t(rep(1, times = n_pp)) * prior_mat_sparse * relLik
	
	#update complete data log-likelihood
	
	new_log_lik <- logL(prot_abund, uniquePepMean, mixing_fract, uniquePepPrecision)
	
	#check for convergence
	
	if(abs(new_log_lik - previous_it) < 0.01 | (t > 30)){
		continue_it <- FALSE
		whole_data_logL <- c(whole_data_logL, new_log_lik)
		t <- t + 1
		}else{
			whole_data_logL <- c(whole_data_logL, new_log_lik)
			t <- t + 1
			previous_it <- new_log_lik
			}
	}

initial_convergence <- t - 1

max_state <- apply(mixing_fract, 1, which.max)
div_max <- n_prot < max_state

for(p in 1:n_p){
	if(div_max[p] == TRUE){
		prior_mat_sparse[p, -(p + n_prot)] <- FALSE
		prior_mat_likadj[p, -(p + n_prot)] <- 0
		}else{
			prior_mat_sparse[p, p + n_prot] <- FALSE
			prior_mat_likadj[p, p + n_prot] <- 0
			}
	}

##### Run the EM again with the new sparse prior

if(prerun_fixed_mat == TRUE){
#lower processor usage, higher memory
sampleEst_list <- list()
samplePrec_list <- list()
for(c in 1:n_c){
	sampleEst_list[[c]] <- uniquePepMean[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse
	samplePrec_list[[c]] <- 0.5*(uniquePepPrecision[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse)
	}
	}

previous_it <- -Inf
continue_it <- TRUE

while(continue_it){
	
	#update protein abundances: using integrated likelihood
	#update protein means
	prot_abund = ((uniquePepMean*uniquePepPrecision) %*% mixing_fract)/(uniquePepPrecision %*% mixing_fract)
	prot_abund <- as.matrix(Matrix(prot_abund, sparse = FALSE))
	prot_abund[is.nan(prot_abund)] <- 0
	
	#update protein precision
	prot_prec <- uniquePepPrecision %*% mixing_fract
	prot_prec[prot_prec < 1] <- 0
	
	#update mixing fract
	
	#evaluate the log-likelihood of sample abundances about the inferred protein abundances with a precision-specific to the signal strength of the samples
	if(prerun_fixed_mat == TRUE){
	sampleLik <- -1*((sampleEst_list[[1]] - (t(prot_abund[1,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec_list[[1]])
	for(c in 2:n_c){
		sampleLik <- sampleLik - ((sampleEst_list[[c]] - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec_list[[c]])
			}
		}else{
			for(c in 1:n_c){
				sampleEst <- uniquePepMean[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse
				samplePrec <- 0.5*(uniquePepPrecision[c,] %*% t(rep(1, times = n_pp)) * prior_mat_sparse)
				if(c == 1){
					sampleLik <- -1*((sampleEst - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec)
					}else{
						sampleLik <- sampleLik - ((sampleEst - (t(prot_abund[c,] %*% t(rep(1, times = n_p)))*prior_mat_sparse))^2*samplePrec)
						}
				}
			}
	
	#correct for purely ambiguous proteins
	weight_store <- list()
	for(ap in ambigprots){
		tmp <- sampleLik[,ap][prior_mat_sparse[,ap]]
		weights <- exp(tmp)/sum(exp(tmp))
		weight_store[[ap]] <- weights
		sampleLik[,ap][prior_mat_sparse[,ap]] <- tmp + sapply(log((prior_p_div^-1 * weights)^-1), function(x){min(x, 0)})
		}
	
	#adjust for prior	
	sampleLik <- prior_mat_likadj + sampleLik
	
	sampleLik_NA <- sampleLik
	sampleLik_NA[!prior_mat_sparse] <- NA
	relLik <- sampleLik - apply(sampleLik_NA, 1, max_non_NA) %*% t(rep(1, times = n_pp)) * prior_mat_sparse
	relLik[prior_mat_sparse] <- exp(relLik[prior_mat_sparse])
	
	liksums <- apply(relLik, 1, sum)
	
	mixing_fract <- 1/liksums %*% t(rep(1, times = n_pp)) * prior_mat_sparse * relLik
	
	#update complete data log-likelihood
	
	new_log_lik <- logL(prot_abund, uniquePepMean, mixing_fract, uniquePepPrecision)
	
	#check for convergence
	
	if(abs(new_log_lik - previous_it) < 0.01){
		continue_it <- FALSE
		whole_data_logL <- c(whole_data_logL, new_log_lik)
		}else{
			whole_data_logL <- c(whole_data_logL, new_log_lik)
			t <- t + 1
			previous_it <- new_log_lik
			}
	}


prot_abund_final <- prot_abund[,1:n_prot]
prot_abund_final[prot_abund_final == 0] <- NA

if(unq_matches_only == TRUE){
	save(prot_abund_final, prot_prec, mixing_fract, whole_data_logL, initial_convergence, max_state, div_max, file = "EMoutputUnq.Rdata")
	}else{
		save(prot_abund_final, prot_prec, mixing_fract, whole_data_logL, initial_convergence, max_state, div_max, file = "EMoutputDeg.Rdata")
	}

}
@

\begin{figure}
<<pepResp, echo = FALSE>>=
#how many peptides are informing a protein trend, with only the largest effect considered
barplot(table(table(max_state[max_state <= n_prot])))
@
\caption{Number of peptides that are informing a protein trend, with only the largest effect considered}
\end{figure}

<<results = "asis", echo = FALSE, >>=
library(xtable)
xtable(table(div_max), caption = "Number of peptides not-conforming to some general protein trend")
@

\begin{figure}
<<EMlikplot, echo = FALSE>>=
plot(whole_data_logL[-1], col = ifelse(c(2:length(whole_data_logL)) <= initial_convergence, "ORANGE", "BLACK"), pch = 16)
@
\caption{Log-likelihood of EM.  First stage (black) allows for a peptide to partially match proteins and partially diverge from the trend, the second stage (orange) thresholds such that a peptide is entirely accounted for by protein trends or entirely departs from plausible trends}
\end{figure}

\begin{figure}
<<rawHM, echo = FALSE>>=
heatmap.2(t(prot_abund_final[,1:n_prot]), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = blue2red(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "black", breaks = seq(-1*max(range(prot_abund_final, na.rm = TRUE)), max(range(prot_abund_final, na.rm = TRUE)), by = max(range(prot_abund_final, na.rm = TRUE))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM}
\end{figure}

<<mv_impute, dependson = "EMrun">>=
library(missMDA)
#determine how many significant principal components should be included based on repeated random sub-sampling validation
pcrange <- c(2,12)
npc.compare <- estim_ncpPCA(prot_abund_final, ncp.min = pcrange[1], ncp.max = pcrange[2], method.cv = "Kfold", pNA = 0.10, nbsim = 50)
npc <- npc.compare$ncp#8

#determine the most likely values of the missing data
impute_abund <- imputePCA(prot_abund_final, npc, scale = FALSE)$completeObs
impute_abund_thresh <- impute_abund
impute_abund_thresh[impute_abund_thresh > 5] <- 5; impute_abund_thresh[impute_abund_thresh < -5] <- -5
@

\begin{figure}
<<mvNpc, echo = FALSE>>=
plot(npc.compare$criterion ~ c(pcrange[1]:pcrange[2]), pch = 16, ylab = "MS error of prediction", xlab = "number of PCs")
abline(v = npc, col = "RED", lwd = 2)
@
\caption{Reconstruction error of raw matrix using PC-based imputation}
\end{figure}

\begin{figure}
<<impHM, echo = FALSE>>=
heatmap.2(t(impute_abund_thresh), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = blue2red(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "black", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM and imputing missing values with missMDA}
\end{figure}



<<plot_proteinTrends>>=
tmp <- Matrix(diag(rep(prior_p_div, times = n_p))); colnames(tmp) <- paste(unique_pepNames, "divergent", sep = "_")
tmp <- as.matrix(tmp)
tmp[!(tmp %in% c(0,1))] <- 1 
prior_mat_logical <- cbind(as.matrix(unique_mappingMat), tmp) 
prior_mat_logical <- prior_mat_logical == 1
possibleMap <- Matrix(prior_mat_logical)

prot_plot_list <- list()
for(p in 1:25){
	prot_plot_list[[p]] <- plot_protein_add(p, possibleMap, prot_abund_final, uniquePepMean, uniquePepPrecision)
	}

multiplot(prot_plot_list, cols =5)
@

Determine the abundance of transcripts corresponding to ascertained proteins

<<>>=

@























\end{document}  
