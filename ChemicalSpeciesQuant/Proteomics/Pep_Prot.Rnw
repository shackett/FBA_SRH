\documentclass[12pt]{article}
\usepackage[left=0.5in,top=0.5in,right=0.5in,bottom=0.5in,nohead]{geometry}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{wrapfig}	%in-line figures
\usepackage[numbers, super]{natbib}		%bibliography
%\usepackage{pslatex} 	%for times new roman
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{aurical}
\usepackage[scaled]{helvet}
\usepackage{multicol}
\usepackage{upquote}
\usepackage{tikz}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\Sexpr{opts_chunk$set(tidy=TRUE, message=FALSE)}
<<setup, echo=FALSE,results='hide'>>=
options(width=80)
library(knitr)

opts_knit$set(progress = TRUE, verbose = TRUE)
opts_chunk$set(echo = FALSE)


setwd('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics')
load('20121109ProtPepMatrices.Rdata')
source("pep_library.R")
plotting_fxn()
matrix_fxn()

blackOrange <- function(n){colorpanel(n, "black", "black", "orange")}
greenBlackRed <- function(n){colorpanel(n, "green", "black", "red")}

library(ggplot2)
library(xtable)

@


\author{Sean R. Hackett}
\title{Peptides to Protein EM (Aggregator) and analysis} 
\date{}

\begin{document}
\SweaveOpts{concordance=TRUE}

\setlength{\parskip}{0.5mm}
\linespread{1}

\thispagestyle{empty}
\pagestyle{empty}

\maketitle


\section*{Data Processing}

\small

<<dataImp, cache=TRUE>>=

quality_frac <- 0.8
ICthreshold <- 2^15
#only consider peptides that match unambiguously to a single protein
unq_matches_only <- FALSE

lightIC[lightIC < ICthreshold] <- NA; heavyIC[heavyIC < ICthreshold] <- NA

good_samples <- rowSums(is.finite(PepMatrix) & !is.na(lightIC) & !is.na(heavyIC)) >= (length(PepMatrix[1,])*quality_frac)

#possible mappings between a protein and all matching peptides
mappingMat <- ProtPepMatrix[good_samples,]
nsharedpep <- table(rowSums(mappingMat))

if(unq_matches_only){
	good_samples[good_samples] <- good_samples[good_samples] & (rowSums(mappingMat) == 1)
	mappingMat <- ProtPepMatrix[good_samples,]
	}
mappingMat <- mappingMat[,colSums(mappingMat) != 0]

#combine degenerate proteins together if all the peptides associated with multiple proteins are shared

degen_prots <- apply(mappingMat, 2, function(prot){
	paste(prot, collapse = "")
	})

degen_prot_patterns <- names(table(degen_prots))[unname(table(degen_prots)) > 1]

degen_prot_matches <- list()
degen_mappings <- NULL
for(pat in 1:length(degen_prot_patterns)){
	
	degen_prot_matches[[paste(colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]], collapse = "/")]] <- colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]]
	degen_mappings <- cbind(degen_mappings, mappingMat[,degen_prots %in% degen_prot_patterns[pat]][,1])
	
	}
colnames(degen_mappings) <- names(degen_prot_matches)	

mappingMat <- cbind(mappingMat[,!(degen_prots %in% degen_prot_patterns)], degen_mappings)	
	


#the relative abundance of a peptide across conditions w.r.t a common reference
abundMat <- PepMatrix[good_samples,]
abundMat[is.infinite(abundMat)] <- NA

good_light <- lightIC[good_samples,]
good_heavy <- heavyIC[good_samples,]

#map measured peaks to unique peptide sequences

pepNames <- rownames(mappingMat)
unique_NameCorr <- sapply(pepNames, function(name){
	unlist(strsplit(name, "\\."))[1]
	})
unique_pepNames <- unique(unique_NameCorr)
unique_NameCorrCol <- sapply(unique_NameCorr, function(name){
	c(1:length(unique_pepNames))[name == unique_pepNames]
	})

pepToUniq <- matrix(0, nrow = length(pepNames), ncol = length(unique_pepNames))
rownames(pepToUniq) <- pepNames; colnames(pepToUniq) <- unique_pepNames
for(i in 1:length(pepNames)){
	pepToUniq[i,unique_NameCorrCol[i]] <- 1
	}
pepToUniq <- Matrix(pepToUniq)

#determine the expectation of the standard deviation as a heteroschedastic fxn of IC using p0.05 light v. p0.05 heavy

avgSignalSTD <- apply(cbind(heavyIC[,colnames(heavyIC) == "P0.05"], lightIC[,colnames(lightIC) == "P0.05"]), 1, mean)
logLight <- log2(lightIC[is.finite(avgSignalSTD),colnames(lightIC) == "P0.05"])
logHeavy <- log2(heavyIC[is.finite(avgSignalSTD),colnames(heavyIC) == "P0.05"])
avgSignalSTD <- avgSignalSTD[is.finite(avgSignalSTD)]
#remove this step to increase variance, since this factor isnt known in principle
logLight <- logLight + optimize(normFactor, c(-1, 1), logLight = logLight, logHeavy = logHeavy)$minimum

#variance of the replicate differences accounting for small sample (scaling factor of 2)
STDvar <- (logLight - logHeavy)^2*2
STDvar_fit <- lm(log2(STDvar) ~ log2(avgSignalSTD))$coef

@

\begin{itemize}
\item Remove all peptides with more than \Sexpr{(1 - quality_frac)*100}\% missing data
\item Remove all peptides with less than \Sexpr{ICthreshold} ions measured
\item This results in \Sexpr{table(good_samples)[names(table(good_samples)) == TRUE]} peptides that are retained and \Sexpr{table(good_samples)[names(table(good_samples)) == FALSE]} peptides which are discarded.
\end{itemize}

Some of the proteins are totally degenerate, i.e. all of the peptides that match them, also match one or more other effectively identical proteins.  To deal with this, These degenerate proteins were combined and the mapping matrix (of peptides - proteins) was consolidated removing these degeneracies, the degenerate proteins were then combined and named according to the genes that they encompass.  These proteins shouldn't be used for transcript $\sim$ protein association, but will be useful for other purposes.

\begin{figure}[h!]
<<repdiffplot1, dependson = "dataImp", echo = FALSE, cache = TRUE>>=
gplot.hexbin(hexbin(logLight, logHeavy, xbins = 200), colramp = rainbow)
@
\label{heavylightcomp}
\caption{Comparison of log$_{2}$p0.05$^{H}$ and log$_{2}$p0.05$^{L}$}
\end{figure}

<<ICsdreg1, dependson = "dataImp", echo = FALSE, include = FALSE, cache = TRUE>>=
plot(log2(STDvar) ~ log2(avgSignalSTD), pch = 16, cex = 0.3)
abline(STDvar_fit, col = "RED")
@

<<ICsdreg2, dependson = "dataImp", echo = FALSE, include = FALSE, cache = TRUE>>=
gplot.hexbin(hexbin(log2(avgSignalSTD), log2(STDvar), xbins = 80), colramp = rainbow)
@


\begin{figure}[h!]
\begin{center}
\subfloat[Linear regression]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg1.pdf}
}
\qquad
\subfloat[Bivariate histogram: residual variance is a decreasing function of signal strength]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg2.pdf}}
\end{center}
\label{repFitSD1}
\caption{$\epsilon^{2}$ versus average log$_{2}$ ion counts of the heavy and light peak}
\end{figure}

<<pooled_variance, dependson = "dataImp", cache = TRUE>>=

meanCtrlIC <- mapply(mean, logHeavy, logLight)
nbins <- 100
binsize <- floor(length(meanCtrlIC)/nbins)
error_bins <- data.frame(val_mean = meanCtrlIC[order(meanCtrlIC)], light_val = logLight[order(meanCtrlIC)], bin = c(rep(1:(length(meanCtrlIC) %% nbins), each = binsize + 1), rep(((length(meanCtrlIC) %% nbins) + 1):nbins, each = binsize)))

bin_var <- data.frame(logIC = rep(NA, times = nbins), MLE_var = rep(NA, times = nbins),  MLE_var2 = rep(NA, times = nbins))
bin_dist_plot <- NULL

for(bin in 1:nbins){
	bin_var$logIC[bin] <- mean(error_bins[error_bins$bin == bin,]$val_mean)
	
	#calculate unbiased estimate of variance
	resid_dist <- (error_bins[error_bins$bin == bin,]$light_val - error_bins[error_bins$bin == bin,]$val_mean)*sqrt(2)
	#get the average residual magnitude and then square for the varianace
	bin_var$MLE_var2[bin] <- mean(abs(resid_dist[abs(resid_dist) < sd(resid_dist)*3]))^2
	
	}

var_spline <- smooth.spline(x = bin_var$logIC, y = bin_var$MLE_var2, df = 5)

@

\begin{figure}
<<pooled_var_plot, echo = FALSE, cache = TRUE>>=
plot(var_spline, type = "l", lwd = 2, ylim = c(0, range(c(predict(var_spline, bin_var$logIC)$y, bin_var$MLE_var2))[2]))
points(bin_var$logIC, bin_var$MLE_var2, pch = 16, cex = 0.8, col = "RED")
@
\caption{pooling peptides by mean($log_{2}^{H}, log_{2}^{L}$) and within these pools looking at the average variance}
\label{poole_var_fig}
\end{figure}

From the results above, the variance of peptide abundances is clearly a decreasing function of peak size.  In order to form a more robust estimate of variance as a function of ion-count, peptides were sorted by mean($log_{2}X^{H}, log_{2}X^{L}$) and pooled into \Sexpr{nbins} binds,  containing \Sexpr{binsize}-\Sexpr{binsize+1} peptides.  The variance within these bins was calculated as according to equation \ref{poolvar}, and a 5$^{th}$ degree spline was fit through these points (figure \ref{poole_var_fig}).  This estimate of V(IC) can be used as a prediction of how close a peptides relative abundance is to the population parameter of interest, the protein mean. 

\begin{align}
\epsilon_{p} &= X_{p}^{H} - X_{p}^{L}\notag\\
\sigma^{2} &= mean(|\epsilon_{p} * \sqrt{2}|)^{2}\label{poolvar}
\end{align}

\normalsize

\begin{figure}[h!]
<<nshare, dependson = "dataImp", echo = FALSE>>=
barplot(nsharedpep)
@
\caption{Number of proteins that a measured peptide matches}
\end{figure}

In order to determine the expected variance of the relative abundance of a peptide($\mathbf{X}_{ic}$ about the relative abundance of its corresponding protein ($\mathbf{\Omega}_{kc}$), we assume that $\mathbf{X}_{ic} \sim N(\mathbf{\Omega}_{kc}, \sigma^{2}_{ic}$) with $E[\sigma^{2}_{ic}]$ being fitted either from residuals or replicates.

Fitting from replicates can be done because all of the samples are quantified with respect to a common reference p0.05, including an experimental sample of p0.05.  The difference between these  



\clearpage
\normalsize

\subsection*{Normalization to account for differences in protein concentrations across conditions}

Determining the intracellular concentration of proteins, the desired normalization measurement required integrating data from several other documents.  Briefly the method involved.

\begin{itemize}
\item For each condition (25 experimental and 2 reference chemostats), 80-400mL was collected on ice and spun down to gather a large pellet of cells.
\item The dry weight of each sample was determined after 36 hours of lyophilization on a speed-vacuum at \textcolor{red}{50$^{o}$C - check}.
\item The sample was resuspended in 900$\mu$L KH$_{2}$PO$_{4}$-EDTA with 0.5\% Triton-X-100, split into 3 replicates and 20$\mu$L of each sub-sample was aliquoted into 12 96-well plates.
\item For the protein assay, 10$\mu$L of one such plate was diluted in 190$\mu$L of the $\mu$L KH$_{2}$PO$_{4}$-EDTA-Triton-X buffer and 9$\mu$L of this diluted sample was quantified using the Thermo BCA protein assay kit. 
\item For cellular volume per mL of media, a Coulter counter was used to count the number and volume of cells in a dilution of media.  The product of the mean cellular volume, number of cells and dilution factor gives the correct quantity.
\item Fraction of protein was calculated by correcting for dilution and splitting and then compared to dry weight.  The concentration of proteins per cell was found by determining the concentration of proteins per mL of media and dividing by the cellular volume per mL of media
\end{itemize}

To correct for differences in protein concentrations between samples, the relative abundances were corrected by adding a factor $\Delta_{j}$, as per equation \ref{normalizeC}.
\begin{align}
\text{Initial loading disparity}&\notag\\
\delta^{o}_{j} &= log_{2}(\text{med}[\frac{P^{L}_{j}}{P^{H}_{j}}])\notag\\
%\text{Desired concentration offset}&\notag\\
%\delta_{j} &= log_{2}([protein^{L}_{j}] - [protein^{H}_{j}])\notag\\
%\Delta_{j} &= \delta_{j}  - \delta^{o}_{j}\notag\\
%X^{*}_{ij} &= X_{ij} + \Delta_{j}\label{normalizeC}
X^{*}_{ij} &= X_{ij} - \delta^{o}_{j}\label{normalizeC}
\end{align}




<<normalizeProtAbund, dependson = "EMprep", cache = TRUE>>=
load('../BulkComposition/protSpecQuantOut.Rdata')

added_conds <- conditions[conditions$condition == "p0.30",]; added_conds$condition <- "p0.30_ORBI"
conditions <- rbind(conditions, added_conds)

cond_info <- sapply(colnames(good_light), function(cond){
	if(strsplit(cond, "")[[1]][1] == "L"){
		tmp <- cond
		}else{
			tmp <- paste(c(tolower(strsplit(cond, "")[[1]][1]), strsplit(cond, "")[[1]][-1]), collapse = "")
			}
		c(1:length(conditions[,1]))[conditions$condition == tmp]
		})

conditions <- conditions[cond_info,]

initial_offset = log2(apply(good_light/good_heavy, 2, median, na.rm = TRUE))

abundMat <- abundMat + rep(1, times = length(abundMat[,1])) %*% t(-1*initial_offset)

@

\begin{figure}[h!]
<<prot_cellular_conc, echo = FALSE, cache = TRUE>>=
pconc_plot <- ggplot(plotting_DF, aes(x = factor(Condition), y = Concentration, col = limitation)) + facet_wrap(~ Iteration, ncol = 1) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("mg protein/uL cellular volume") + scale_x_discrete("Experimental condition")
pconc_plot + geom_boxplot() 
@
\caption{Concentration of proteins (mg) per $\mu$L cellular volume.  The top panel contains the raw transformed protein concentrations.  It is notable that some treatments are measured poorly, with a great discordance between technical replicates.  There is a strong linear trend across dilution rates within each limitation, so this could serve as a fitted value for each condition.  To minimize the influence of outliers, we want to find a point estimate of the concentration of protein in each condition that balances the actual possibly noisy value measured, with the predicted value from the structure of the data.  The balance of using the experimental measurement or the fitted value is determined by how noisy the experimental measurement is relative to the residual mean square error of the regression fit.}
\label{prot_cellular_conc}
\end{figure}

\begin{figure}[h!]
<<prot_frac_DW, echo = FALSE, cache = TRUE>>=
dw_plot <- ggplot(dry_weight_DF, aes(x = factor(condition), y = ProteinDW_fraction, col = limitation)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Protein fraction of dry-material") + scale_x_discrete("Experimental condition")
dw_plot + geom_boxplot()
@
\caption{Fraction of dry weight taken up by proteins}
\label{prot_frac_DW}
\end{figure}

\begin{figure}[h!]
<<dry_weight_dens, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot1 <- ggplot(dry_weight_turnover_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight(mg) per mL culture", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot1 + geom_bar(stat = "identity", position = "stack")
@
\caption{Dry weight (mg) per mL of culture: Maximal density is seen at low growth rates except under carbon and leucine limitation}
\label{dry_weight_dens}
\end{figure}

\begin{figure}[h!]
<<dry_weight_turnover, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot2 <- ggplot(dry_weight_turnover_DFmelt2, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight production (mg/hr) per mL culture", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot2 + geom_bar(stat = "identity", position = "stack")
@
\caption{Dry weight per mL * DR (h$^{-1}$ indicates that optimal growth, in terms of biomass production occurs at intermediate GRs}
\label{dry_weight_turnover}
\end{figure}

\begin{figure}[h!]
<<dry_weight_cellconc, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot3 <- ggplot(dry_weight_turnover_D_cellular_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight (mg) per uL of cellular volume", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot3 + geom_bar(stat = "identity", position = "stack")
@
\caption{Concentration of proteins and dry-matter per cellular volume (mg/uL).  The protein relative concentrations are equivalent to the means of the figure \ref{prot_cellular_conc} box plot}
\label{dry_weight_cellconc}
\end{figure}

\begin{figure}[h!]
<<material_percell, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_perCell_plot <- ggplot(dry_weight_perCell_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold"), panel.grid.minor=element_blank(), panel.grid.major=element_blank()) + scale_y_continuous("pg protein/dry-material per cell", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_perCell_plot + geom_bar(stat = "identity", position = "stack")
@
\caption{pico-grams protein per cell: The smaller size of nitrogen and carbon limited cells results in them having less material per-cell.  For most conditions, at slow growth-rates cells either become minute or huge and then tend back towards a similar intermediate size as growth-rates increase.  This makes carbon and C, N and L look more similar in terms of total material per cell, while uracil looks radically different}
\label{material_percell}
\end{figure}





\small

<<EMsetup, dependson = "dataImp", cache = TRUE>>=

#calculate the expected sampling variance of the heavy-low diff for experimental measurement

lightHeavyCellmean <- sapply(c(1:length(heavyIC[,1]))[good_samples], function(row){
	mapply(FUN = function(a,b){
		if(!is.na(a) & !is.na(b)){mean(a, b)}else{NA}
		}, lightIC[row,], heavyIC[row,])
	})



#fittedVar <- var_calc(lightHeavyCellmean, STDvar_fit)

fittedVar <- apply(log2(lightHeavyCellmean), c(1,2), function(x){
	if(is.na(x)){NA}else{
		predict(var_spline, x)$y
		}
	})

fittedPrec <- fittedVar^-1

#for each unique peptide, combine the multiple ionization states to produce a single point estimate, using integrated likelihood

#set the precision of missing values to 0; equivalent to no impact, infinite variance

fittedPrec[t(is.na(abundMat))] <- 0
fittedPrec[is.na(fittedPrec)] <- 0
abundMat[t(fittedPrec) == 0] <- 0

n_p = length(unique_pepNames) #4042
n_prot <- length(mappingMat[1,])
n_pp = n_p + n_prot #4964
n_c = length(abundMat[1,]) #15

uniquePepMean <- matrix((((t(abundMat) * fittedPrec) %*% pepToUniq)/(fittedPrec %*% pepToUniq)), ncol = n_p, nrow = n_c)
uniquePepPrecision <- Matrix(fittedPrec %*% pepToUniq)
uniquePepMean[is.nan(uniquePepMean)] <- NA

#change mapping from peptides to unique peptides (averaging over ionization states)
unique_mappingMat <- as.matrix(t(pepToUniq) %*% mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)


#number of non-missing values for peptides
Nmissing_val <- table(rowSums(!is.na(t(uniquePepMean))))

uniquePepMean[is.na(uniquePepMean)] <- 0

#number of non-missing values for all peptides (before uniquenss combination)
Nmissing_val_all <- table(apply(is.finite(PepMatrix), 1, sum))

@

<<results = "asis", echo = FALSE>>=
print(xtable(data.frame(Proteins = n_prot, Peptides = n_p, Conditions = n_c), display = c("s", "d", "d", "d")), include.rownames = FALSE)
@


\begin{figure}[h!]
<<mvbarplot, dependson = "EMsetup", echo = FALSE>>=
barplot(table(apply(is.finite(PepMatrix), 1, sum)), col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val_all)) < ceiling(n_c * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val_all)) >= ceiling(n_c * quality_frac)))))
@
\caption{Distribution of non-missing values for all peptides.  Peptides with non-missing values over the cutoff are shown in orange}
\label{nonmissingvals}
\end{figure}


<<mvmat, dependson = "EMsetup", cache = TRUE>>=

#look at structure in the missing values
binPepMatrix <- ifelse(is.finite(lightIC), 1, 0)

pnonmissingOverSingles <- matrix(NA, ncol = length(binPepMatrix[1,]), nrow = length(binPepMatrix[1,]))
rownames(pnonmissingOverSingles) <- colnames(binPepMatrix); colnames(pnonmissingOverSingles) <- colnames(binPepMatrix)
pnonmissingOverTotal <- pnonmissingOverSingles
for(i in 1:length(pnonmissingOverSingles[1,])){
	for(j in 1:length(pnonmissingOverSingles[1,])){	
	pnonmissingOverTotal[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2)/length(binPepMatrix[,1])
  	pnonmissingOverSingles[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2) / sum(apply(binPepMatrix[,c(i, j)], 1, sum) > 0)
	}
}

@

<<missingOverlap1, dependson = "mvmat", label = "missingOverlap1", echo = FALSE, include = FALSE, cache = TRUE>>=
heatmap.2(pnonmissingOverTotal, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

<<missingOverlap2, dependson = "mvmat", label = "missingOverlap2", echo = FALSE, include = FALSE, cache = TRUE>>=
heatmap.2(pnonmissingOverSingles, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

\begin{figure}[h!]
\begin{center}
\subfloat[p(A $\cap$ B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap1}
}
\qquad
\subfloat[A $\cap$ B / max(A, B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap2.pdf}}
\end{center}
\label{repFitSD2}
\caption{Overlap of missing ascertained peptides across conditions}
\end{figure}

\begin{figure}
<<missingPepbyCond, cache = TRUE>>=
plot(apply(is.na(lightIC), 2, sum) ~ c(apply(lightIC, 2, sum, na.rm = TRUE) + apply(heavyIC, 2, sum, na.rm = TRUE)), col = as.factor(conditions$limitation), pch = 16)
@
\caption{Number of missing peptide values for an experiment versus limitation and TIC.  The point in the top-right is measured on an Orbi-trap.  Its large number of missing peptides, equivalent to the TOF suggests that the large number of missing peptides under phosphate limitation is due to blocking effects or biology rather than the Q-TOF not behaving appropriately during the first run}
\end{figure}


<<mvmat_red, dependson = "mvmat", cache = TRUE>>=
uq_ProtPepMatrix <- ProtPepMatrix[rowSums(ProtPepMatrix) == 1,]
uq_binPepMatrix <- binPepMatrix[rowSums(ProtPepMatrix) == 1,]

cond_peps <- t(((t(uq_binPepMatrix) %*% uq_ProtPepMatrix) != 0)*1)
cond_peps <- cond_peps[!(rowSums(cond_peps) %in% c(0, length(cond_peps[1,]))),]

@

\begin{figure}[h!]
<<misval_HM, dependson = "mvmat_red", echo = FALSE, warning = FALSE, cache = TRUE>>=
man_dist <- function(x){dist(x, method = "manhattan")}
heatmap.2(cond_peps, Rowv = TRUE, Colv = FALSE, trace = "none", col=blackOrange(100), distfun = man_dist, cexRow = 0.1)
@
\caption{hierarchical clustering of proteins missing in a subset of conditions using manhattan distance - a similarly clustered matrix for peptides is outputted but beyond R's clustering capabilities}
\end{figure}


<<cluster_misval, dependson = "mvmat_red", cache = TRUE>>=
	
k_clust_misVal <- 5

mv_clust <- stepFlexclust(cond_peps, k = k_clust_misVal, nrep=100, verbose=FALSE, FUN = kcca, family = kccaFamily(which = 'kmedians'))

clust_counts1 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)
clust_counts0 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)

for(kval in 1:k_clust_misVal){
	binsub <- cond_peps[mv_clust@cluster == kval,]
	clust_counts1[kval,] <- colSums(binsub)
	clust_counts0[kval,] <- length(binsub[,1]) - colSums(binsub)
	}
clust_ypos_adj <- matrix(5*rep(0:(k_clust_misVal-1), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_xpos <- matrix(rep(1:n_c, times = k_clust_misVal), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_num <- matrix(rep(1:(k_clust_misVal), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)

clust_plot_df <- data.frame(condition = c(c(clust_xpos), c(clust_xpos)), cluster_val = c(c(1 + clust_ypos_adj), c(clust_ypos_adj)),counts = c(c(clust_counts1), c(clust_counts0)), shape = as.factor(c(c(clust_num), c(clust_num))), medianoid = as.factor(c(c(mv_clust@centers), c(1 - mv_clust@centers))))

@

\begin{figure}[h!]
<<plot_missingvalClusters, dependson = "cluster_misval", echo = FALSE, cache = TRUE>>=
clust_plot <- ggplot(clust_plot_df, aes(x = condition, y = cluster_val, size = counts, color = medianoid))
clust_plot <- clust_plot + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
clust_plot + geom_point()
@
\end{figure}

<<GSEA_prep, cache = TRUE>>=
library(GSEABase)
library(org.Sc.sgd.db)

frame = toTable(org.Sc.sgdGO)

goframeData = data.frame(frame$go_id, frame$Evidence, frame$systematic_name)
goFrame=GOFrame(goframeData,organism="Saccharomyces cerevisiae")
goAllFrame=GOAllFrame(goFrame)
gsc <- GeneSetCollection(goAllFrame, setType = GOCollection())
@

<<perform_GSEA, dependson= c("GSEA_prep", "cluster_misval"), cache = TRUE>>=
library(methods)
library(GOstats)
library(GSEABase)
FDR = .05

#MF - molecular function, BP - biological process, CC cellular component
GSEA.test = function(genes, category) {
	universe = rownames(cond_peps)
	
	params <- GSEAGOHyperGParams(name="GSEA for Bar-Seq data",
		geneSetCollection=gsc,
		geneIds = genes,
		universeGeneIds = universe,
		ontology = category,
		pvalueCutoff = 1,
		conditional = FALSE,
		testDirection = "over")
	hyperGTest(params)
	}

sum_table <- NULL
for(kval in 1:k_clust_misVal){
	test <- names(mv_clust@cluster[mv_clust@cluster == kval])
	for(ont in c("MF", "BP", "CC")){
		go_sum <- summary(GSEA.test(test, ont))
		lowp <- go_sum[go_sum$Pvalue < 0.001,]
		if(length(lowp[,1]) != 0){
			colnames(lowp)[1] <- "GOID"
			sum_table <- rbind(sum_table, cbind(k = kval, category = ont, lowp))
			}
		}
	}
@

<<GSEAtable, dependson = "perform_GSEA", results = "asis", echo = FALSE>>=
xtable(sum_table, digits = 5)
@






\clearpage
\normalsize
\section*{Going from peptides to proteins via expectation-maximization}

When using relative variation in peptides to predict variation in protein abundance we need to deal with two factors
\begin{itemize}
\item If a peptide maps to multiple proteins, it should be attributed to a protein (thereby adding signal) to the extent that its pattern matches the pattern from other peptides.
\item Some peptides won't conform to the trends of their protein because they may be the non-covalently modified complement of a set of unascertained modified peptides.  These peptides shouldn't inform the general protein trend, and may be interesting to analyze in isolation.
\end{itemize}

\subsection*{Algorithm structure}

\begin{itemize}
\item[\textbf{X}:] [I $\cdot$ C] Data matrix: Input MS data of the relative abundance of each peptide across C conditions
\item[\textbf{M}:] [I $\cdot$ J] Possible mappings between peptides (I) and proteins (J)
\item[$\mathbf{\Theta}$:] [I $\cdot$ K] Responsibility matrix: prob that peptide i belongs to protein j or shows a divergent trend which should be described separately.  K = I + J
\item[$\mathbf{\Omega}$:] [K $\cdot$ C] Point estimate for each species$\cdot$condition.
\item[$\sigma^{2}$:] [I] Fitted variance relative to peptide IC.
\end{itemize}

\begin{align}
p(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &\propto \prod_{i}^{I}\prod_{c}^{C} \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i}) \cdot \mathbf{\Theta}p(\mathbf{\Theta})\notag\\
\textit{l}(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &= \sum_{i}^{I}\sum_{c}^{C} \textit{ln}\left( \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i})\right)\notag\\
+ \sum_{i}^{I}\sum_{k}^{K}\mathbf{\Theta_{ik}}p(\mathbf{\Theta_{ik}})
\end{align}


\subsection{Updating $\mathbf{\Theta}$}

\begin{align}
\mathbf{\Theta}_{ik} \sim \frac{\textbf{N}(\mathbf{\Omega}_{kC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ik})}{\sum_{b = 1}^{K}\textbf{N}(\mathbf{\Omega}_{bC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ib})}
\end{align}

\subsection{Updating $\mathbf{\Omega}$}

$\tau_{y} = \prod_{z \neq y}^{Y}\sigma^{2}_{z}$

\begin{align}
\mathbf{\Omega}_{kc} \sim \mbox{\Large \textbf{N}}\left(\mu = \frac{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\textbf{X}_{ic}\tau_{i}}{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\tau_{i}}, \sigma^{2} =  \left(\sum_{i = 1}^{I}\frac{\mathbf{\Theta}_{ik}}{\sigma^{2}_{i}}\right)^{-1} \right)
\end{align}

\subsubsection*{Notes}

\begin{itemize}
\item For every protein that only has peptides that are shared by other proteins, there is little evidence that this protein exists unless the shared peptides exhibit a trend that diverges from the behavior of the shared proteins (as determined by its unique peptides).  
\end{itemize}



\subsection*{Algorithm Implementation}

\scriptsize

<<EMprep>>=	
			
### Iteration ###

prerun_fixed_mat <- TRUE

### Initalization ###

prior_bound <- 0.9999
prior_p_div <- exp(-1*qchisq(prior_bound, n_c))

#if a putative protein only has component peptides which are matched to other proteins than penalize any assignment to it by the supremum of the mixing fraction

#number of shared peptides per protein
pepshared <- colSums(unique_mappingMat[c(1:n_p)[rowSums(unique_mappingMat) > 1],])
#total peptides per protein
peptotal <- colSums(unique_mappingMat)
ambigprots <- c(1:n_prot)[pepshared == peptotal]

if((unq_matches_only == TRUE & file.exists("EMoutputUnq.Rdata"))|(unq_matches_only == FALSE & file.exists("EMoutputDeg.Rdata"))){
	if(unq_matches_only == TRUE){
		load("EMoutputUnq.Rdata")
			}else{
			load("EMoutputDeg.Rdata")
			}
	}else{
	save(unq_matches_only, prerun_fixed_mat, prior_p_div, uniquePepMean, uniquePepPrecision, unique_pepNames, unique_mappingMat, n_p, n_pp, n_prot, n_c, ambigprots, file = "EMimport.Rdata")
	#system("R64 callEM.R")

	}


matched_prots <- apply(mixing_fract[,1:n_prot], 2, sum) > 0.5
apply(mixing_fract[,1:n_prot], 2, sum)[alpha_pres == 0]
prot_abund_final <- prot_abund[,c(1:n_prot)[matched_prots]]
prot_abund <- prot_abund[,-c(1:n_prot)[!matched_prots]]
prot_prec <- prot_prec[,-c(1:n_prot)[!matched_prots]]
mixing_fract <- mixing_fract[,-c(1:n_prot)[!matched_prots]]

prot_abund_final[prot_abund_final == 0] <- NA

n_prot <- length(prot_abund_final[1,])	
@




\normalsize
After carrying out EM, \Sexpr{sum(!matched_prots)} proteins were discarded because they overlapped ascertained proteins and had no strong solitary evidence of being present.  This leaves\Sexpr{n_prot} proteins for further analysis.  


\begin{figure}
<<pepResp, echo = FALSE>>=
#how many peptides are informing a protein trend, with only the largest effect considered
barplot(table(table(max_state[max_state <= n_prot])))
@
\caption{Number of peptides that are informing a protein trend, with only the largest effect considered}
\end{figure}

<<results = "asis", echo = FALSE, >>=
xtable(table(div_max), caption = "Number of peptides not-conforming to some general protein trend")
@

\begin{figure}
<<EMlikplot, echo = FALSE>>=
plot(whole_data_logL[-1], col = ifelse(c(2:length(whole_data_logL)) <= initial_convergence, "BLACK", "ORANGE"), pch = 16)
@
\caption{Log-likelihood of EM.  First stage (black) allows for a peptide to partially match proteins and partially diverge from the trend, the second stage (orange) thresholds such that a peptide is entirely accounted for by protein trends or entirely departs from plausible trends}
\end{figure}

\begin{figure}
<<div_match_comp, dependson = "EMprep", echo = FALSE>>=
likdiff_plot <- ggplot(likdiff_df, aes(x = likelihood, fill = matched))
likdiff_plot + geom_histogram()
@
\caption{difference between the log-likelihood of a peptide-protein match and a peptide failing to match.  Matches are colored teal and non-matched orange}
\label{likdiff_plot}
\end{figure}

\normalsize

Peptides that conform to a protein well will have a moderately high log-likelihood, bounded on the top by 0.  An alternative option is when a peptide fails to conform to a protein.  Because this protein's mean across conditions will be free, the log-likelihood of this unconstrained model will equal zero.  The difference in degrees of freedom between these two models is equal to the number of experimental conditions.  Comparing a model where the mean is constrained across \Sexpr{n_c} conditions, with it being unconstrained.  The change in log-likelihood that we would expect this constraint to cause would be $\chi^{2}_{\Sexpr{n_c}}$ distributed.  The equivalent of having a $\frac{1}{10000}$ chance of as large an increase in logL happening by chance given that a peptide actually has the same trend as a protein would be an increase in the logL of \Sexpr{qchisq(prior_bound, n_c)}.  To implicitly carry out this hypothesis during optimization, the likelihood of the peptide not matching is penalized by the subtraction of this prior and compared to the likelihood of the best peptide-protein match.  A plot of the log-likelihood difference between a fit between a peptide and the best-fitting protein is shown in figure \ref{likdiff_plot}.  

<<phosphoSiteEnrich, results = "asis", cache = TRUE>>=
### Read in phospho peptide data from phosphoGRID ###
library("stringr")

phospho_sites <- read.delim('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics/phosphosites.txt', skip = 32, header = TRUE, stringsAsFactors = FALSE)

phospho_sites_red <- phospho_sites[,colnames(phospho_sites) %in% c("A", "C", "R")]

Psites <- cbind(knownPsites(divergentPep_summary, phospho_sites_red), knownPsites(background_SRYfreq, phospho_sites_red))
colnames(Psites) <- c("Divergent", "Matched")

xtable(Psites, caption = "Number of peptides within the protein-matched and non-matched classes which contain a phosphoGRID-annotated phosphorylation site", label = "phosphoSites")
@


In order to see if divergent peptides were enriched for phosphorylation sites, they were compared with known phosphorylation sites from phosphoGRID, to determine how many of the peptide intervals of matched and non-matched peptides contained known phospho-sites.  This produced the contingency table (table \ref{phosphoSites}), which has a significant enrichment of phospho-sites (\Sexpr{round(Psites[2,1]/sum(Psites[,1]), 3)} vs. \Sexpr{round(Psites[2,2]/sum(Psites[,2]), 3)}) according to a chi-square test (p-value: \Sexpr{signif(chisq.test(Psites)$p.value)}).


\begin{figure}
<<rawHM, echo = FALSE, cache = TRUE>>=
heatmap.2(t(prot_abund_final), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(prot_abund_final, na.rm = TRUE)), max(range(prot_abund_final, na.rm = TRUE)), by = max(range(prot_abund_final, na.rm = TRUE))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM}
\end{figure}



<<MVimputeCompare, dependson = "EMrun", cache = TRUE>>=
library(missMDA)
#determine how many significant principal components should be included based on repeated random sub-sampling validation
pcrange <- c(2,18)
npc.compare <- estim_ncpPCA(prot_abund_final, ncp.min = pcrange[1], ncp.max = pcrange[2], method.cv = 'Kfold', pNA = 0.10, nbsim = 50)
npc <- (pcrange[1]:pcrange[2])[npc.compare$criterion < (max(npc.compare$criterion) - min(npc.compare$criterion))*0.01 + min(npc.compare$criterion)][1]

@



<<MVimputeData, dependson = "MVimputeCompare", cache = TRUE>>=
library(impute)

#determine the most likely values of the missing data using KNN imputation

impute_abund  <- impute.knn(as.matrix(prot_abund_final), k = 10)$data
impute_abund_thresh <- impute_abund
impute_abund_thresh[impute_abund_thresh > 5] <- 5; impute_abund_thresh[impute_abund_thresh < -5] <- -5
@

\begin{figure}
<<mvNpc, echo = FALSE>>=
plot(npc.compare$criterion ~ c(pcrange[1]:pcrange[2]), pch = 16, ylab = "MS error of prediction", xlab = "number of PCs")
abline(v = npc, col = "RED", lwd = 2)
@
\caption{Reconstruction error of raw matrix using PC-based imputation, in order to determine an appropriate number of principal components}
\end{figure}

\begin{figure}
<<impHM, echo = FALSE, cache = TRUE>>=
heatmap.2(t(impute_abund_thresh), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM and imputing missing values with missMDA}
\end{figure}

\begin{figure}
<<PC_heatmap, cache = TRUE>>=
impSVD <- svd(t(impute_abund), nu = npc, nv = npc)
impSVD_pcs <- impSVD$v
colnames(impSVD_pcs) <- paste("PC", c(1:npc))
rownames(impSVD_pcs) <- rownames(impute_abund)

heatmap.2(t(impSVD_pcs), Colv = FALSE, Rowv = FALSE, trace = "none", col = greenred(100), dendrogram = "none", colsep = c(5,10,15,21), denscol = "white")
@
\caption{Significant principal components governing variation across conditions in relative protein abundance}
\label{protPCHM}
\end{figure}

\begin{figure}
<<proteinScree>>=
plot((impSVD$d)^2 / sum((impSVD$d)^2) ~ c(1:length(impSVD$d)), pch = 16, cex = 2, col = "RED", xlab = "PC Number", ylab = "fraction of variance explained")
@
\caption{Scree plot: fraction of variance explained by PCs}
\end{figure}

<<PC_traces, cache = TRUE>>=
library(reshape)

pc_plot_df <- melt(impSVD_pcs)
colnames(pc_plot_df) <- c("condition", "PC", "value")
pc_plot_df$cond <- factor(sapply(as.character(pc_plot_df$condition), function(x){unlist(strsplit(x, ""))[1]})) 
pc_plot_df$PC <- factor(pc_plot_df$PC, levels = paste("PC", c(1:npc)))

factor_plot <- ggplot(pc_plot_df, aes(x = condition, y = value, group = cond, col = PC)) + facet_wrap(~ PC, ncol =2, scales = "free_y") + scale_x_discrete("Experimental condition") + theme(axis.text.x = element_text(size = 3, face = "bold"))
factor_plot + geom_line()
@

<<plot_proteinTrends, dependson = "MVimputeData", cache = TRUE, warning = FALSE, cache = TRUE>>=
tmp <- Matrix(diag(rep(prior_p_div, times = n_p))); colnames(tmp) <- paste(unique_pepNames, "divergent", sep = "_")
tmp <- as.matrix(tmp)
tmp[!(tmp %in% c(0,1))] <- 1 
prior_mat_logical <- cbind(as.matrix(unique_mappingMat[,matched_prots]), tmp) 
prior_mat_logical <- prior_mat_logical == 1
possibleMap <- Matrix(prior_mat_logical)
@



\begin{figure}[h!]
<<protPlot1, dependson = c("setup", "EMprep"), warning = FALSE>>=
source("pep_library.R")
set.seed(1234)
gene_samples <- sample(c(1:n_prot), 20)
plotting_names <- orf2common(colnames(prot_abund_final))

plot_protein_lattice(gene_samples[1:5], possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 1)
@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}

\begin{figure}[h!]
<<protPlot2, dependson = c("setup", "EMprep"), warning = FALSE>>=
plot_protein_lattice(gene_samples[6:20], possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 3)
@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}

\begin{figure}[h!]
<<protPlot3, dependson = c("setup", "EMprep"), warning = FALSE>>=
plot_protein_lattice(c(27,32,42,114,183,206,220,222,229,241,264,308), possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 3)
@
\caption{Putative PTMs}
\end{figure}


\section*{Metabolic proteins}

<<metGenerep, dependson = "EMprep", results = "asis", cache = TRUE>>=

rxnFile <- read.delim('~/Desktop/Rabinowitz/FBA_SRH/Yeast_genome_scale/rxn_yeast.tsv', stringsAsFactors = FALSE)
met_genes <- NULL
for(met_gene in rxnFile$MetName[is.na(rxnFile$StoiCoef)]){
	met_genes <- c(met_genes, unlist(met_gene))
	}
met_genes <- unique(met_genes)
measured_genes <- unlist(sapply(colnames(prot_abund_final), function(x){strsplit(x, "/")}))

overlapping_geneN <- length(intersect(met_genes, measured_genes))

met_gene_overlap <- data.frame(intersection = overlapping_geneN, metTot = length(met_genes), measuredTot = length(measured_genes))

print(xtable(met_gene_overlap, caption = "Investigating the overlap of metabolic enzymes (from the yeast consensus metabolic network (v5) and the proteins measured in our dataset"), include.rownames = FALSE)
@


How many metabolic genes are represented in our ascertained proteins: Using the Yeast consensus metabolic reconstruction (version 5), \Sexpr{length(met_genes)} genes involved in some reaction were assembled.  

\clearpage

\section*{Comparing protein and transcript trends}


Determine the abundance of transcripts corresponding to ascertained proteins

<<ModifyTransc, dependson = "MVimputeData", cache = TRUE, message = FALSE>>=
library(impute)

transcript_brauer <- read.delim("../brauer-microarray/Brauer_2008.pcl")
rownames(transcript_brauer) <- transcript_brauer$SYSTEMATIC_NAME
transcript_brauer <- transcript_brauer[-1,-c(1:3)]

#remove genes with many missing values
#impute missing values with KNN imputation (as per original Brauer paper)

transcript_brauer <- transcript_brauer[rowSums(!is.na(transcript_brauer)) > 0.5*length(transcript_brauer[1,]),]
transcript_brauer <- impute.knn(as.matrix(transcript_brauer), k = 10)$data
n_trans_pc <- 12
trans_svd <- svd(transcript_brauer, nu = n_trans_pc, nv = n_trans_pc)

#switch reference from C0.30 (paper says C0.25, but C0.30 is correct) to P0.05 by using fitting a n_trans_pc principal component projection of the data and then taking the difference between these two conditions for each gene.  

offset_projection <- trans_svd$u %*% diag(trans_svd$d[1:n_trans_pc]) %*% t(trans_svd$v[sapply(c("ClimD.3", "PlimD.05.2") , function(cond){c(1:length(transcript_brauer[1,]))[colnames(transcript_brauer) == cond]}),])
transc_renorm_offset <- offset_projection[,2] - offset_projection[,1]

transcript_brauer <- transcript_brauer - transc_renorm_offset


transcript.condition <- as.data.frame(matrix(NA, ncol = 36, nrow = 2))
colnames(transcript.condition) <- colnames(transcript_brauer)
rownames(transcript.condition) <- c("limitation", "GR")
limitations <- c("C", "N", "P", "S", "L", "U")
transcript.condition[1,] <- rep(limitations, each = 6)
transcript.condition[2,] <- rep(c(0.05, 0.10, 0.15, 0.20, 0.25, 0.30), times = 6)

#missing mappings
missing_on_array <- colnames(impute_abund)[!(colnames(impute_abund) %in% rownames(transcript_brauer))]
length(missing_on_array)
genes_to_compare <- colnames(impute_abund)[colnames(impute_abund) %in% rownames(transcript_brauer)]

#determine the relative abundance of array data by looking at the corresponding condition and imputing unobserved growth rates by drawing a line between the abundance of flanking conditions

tmp <- sapply(genes_to_compare, function(match){
	transcript_brauer[rownames(transcript_brauer) == match,]
	})
transcript_brauer_reduced <- matrix(unlist(tmp), ncol = length(tmp[1,]), nrow = length(tmp[,1]))
colnames(transcript_brauer_reduced) <- colnames(tmp); rownames(transcript_brauer_reduced) <- rownames(tmp)


#load true dilution rates for each of the proteomics samples
load('~/Desktop/Composition/RNA_abundance/RNAabundance.R')

prot_cond <- as.data.frame(matrix(NA, ncol = n_c, nrow = 2))
prot_cond <- sapply(rownames(impute_abund), function(cond){
	c(unlist(strsplit(cond, '[0-9]+'))[1], unlist(strsplit(cond, '[A-Z]'))[2])
	})
colnames(prot_cond) <- rownames(impute_abund)
rownames(prot_cond) <- c("limitation", "GR")
prot_cond <- as.data.frame(cbind(t(prot_cond), realDR = NA), stringsAsFactors = FALSE)
prot_cond$realDR <- sapply(1:length(prot_cond[,1]), function(cond){
	RNAabund$actual.dr[grep(paste(prot_cond$limitation[cond], prot_cond$GR[cond], sep = ""), RNAabund$condition, ignore.case = TRUE)[1]]
	})
#remove invalid conditions (not the core set)
prot_cond_bu <- prot_cond
prot_cond <- prot_cond[!is.na(prot_cond$realDR),]

DR_change_mat <- matrix(0, nrow = length(transcript.condition[1,]), ncol = length(prot_cond[,1]))
colnames(DR_change_mat) <- rownames(prot_cond); rownames(DR_change_mat) <- colnames(transcript.condition)
for(cond in 1:length(prot_cond[,1])){
	#find the 2 closest DR within the same limitation
	c_match <- c(1:length(transcript.condition[1,]))[transcript.condition[1,] %in% prot_cond[cond,]$limitation]
	flanking_match <- c_match[order(abs(as.numeric(transcript.condition[2,c_match]) - prot_cond[cond,]$realDR))[1:2]]
	lb_diff <- (prot_cond$realDR[cond] - as.numeric(transcript.condition[2,flanking_match])[1])/diff(as.numeric(transcript.condition[2,flanking_match]))
	DR_change_mat[flanking_match,cond] <- c((1-lb_diff), lb_diff)
	}
	
remapped_transc <- t(transcript_brauer_reduced) %*% DR_change_mat
@

\begin{figure}
<<transHM, dependson = "ModifyTransc", echo = FALSE, cache = TRUE>>=
heatmap.2(remapped_transc, trace = "none", Colv = NULL, dendrogram = "row", na.rm = TRUE, na.color = "white", col = greenBlackRed(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\label{Hierarchical clustering of interpolated transcript values of transcripts corresponding to ascertained proteins}
\end{figure}

<<PTcor, dependson = "ModifyTransc", cache = TRUE>>=
#measure the correlation of the transcript and protein matrix

shared_prot <- impute_abund[,(colnames(impute_abund) %in% rownames(transcript_brauer))] 
shared_prot <- shared_prot[!is.na(prot_cond_bu$realDR),]

shared_trans <- t(remapped_transc)

#center each sample #remove when normalization factor is known
shared_prot <- shared_prot - t(t(apply(shared_prot, 1, mean))) %*% t(rep(1, times = length(shared_prot[1,])))
shared_trans <- shared_trans - t(t(apply(shared_trans, 1, mean))) %*% t(rep(1, times = length(shared_trans[1,])))

pt_corrs <- sapply(c(1:length(shared_prot[1,])), function(row){
	cor(shared_prot[,row], shared_trans[,row], method = "spearman")
	}); pt_corrs <- data.frame(correlation = pt_corrs)

@

\begin{figure}[h!]
<<pairedTPheatmap, dependson = "PTcor", echo = TRUE>>=
n_c_shared <- length(shared_trans[,1])
jointTPdf <- t(rbind(shared_trans, shared_prot))[,rep(1:n_c_shared, each = 2) + rep(c(0,n_c_shared), times = n_c_shared)]
  
heatmap.2(jointTPdf, trace = "none", Colv = NULL, dendrogram = "row", na.rm = TRUE, na.color = "white", col = greenBlackRed(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250), ColSideColors = rep(c("BLUE", "YELLOW"), times = n_c_shared), main = "paired transcript and protein relative abundance")
@
\caption{Relative abundance for genes with a an unambiguous protein measured and the corresponding transcriptional changes.  Adjacent columns are pairs, with column labels reflecting: \textcolor{blue}{transcriptional changes} and \textcolor{yellow}{protein changes}.}
\end{figure}


\begin{figure}
<<globalPTcomp, dependson = "PTcor", echo = FALSE>>=
library(reshape)

pool_tresh <- 4
shared_prot_pool <- shared_prot; shared_prot_pool[shared_prot_pool < -1*pool_tresh] <- -1*pool_tresh; shared_prot_pool[shared_prot_pool > pool_tresh] <- pool_tresh
shared_trans_pool <- shared_trans; shared_trans_pool[shared_trans_pool < -1*pool_tresh] <- -1*pool_tresh; shared_trans_pool[shared_trans_pool > pool_tresh] <- pool_tresh

PTscatterDF <- cbind(melt(shared_trans_pool), melt(shared_prot_pool)$value)
colnames(PTscatterDF) <- c("Condition", "Gene", "Transcript", "Protein")

hex_bin_max <- 500
n_hex_breaks <- 8
hex_breaks <- round(exp(seq(0, log(500), by = log(500)/8)))

PTscatter_plotter <- ggplot(cbind(PTscatterDF, z = 1), aes(x = Protein, y = Transcript, z = z)) + scale_x_continuous("Relative protein abundance") + scale_y_continuous("Relative transcript abundance") + scale_fill_gradient(low = "black", high = "firebrick1", name = "count", trans = "log", breaks = hex_breaks, labels = hex_breaks) 
PTscatter_plotter + geom_hex()  

@
\caption{Global correlation between relative protein abundance and relative transcript abundance}
\end{figure}


\begin{figure}
<<PTspearcorr, dependson = "PTcor", echo = FALSE>>=

cor_plot <- ggplot(pt_corrs, aes(x = correlation))
cor_plot + xlab("spearman correlation") + geom_histogram(colour = "white", fill = "limegreen", binwidth = 0.04)
@
\caption{Distribution of spearman correlations across transcript-protein pairs}
\end{figure}

<<fileDump1, dependson = "c(mvmat_red, mv_impute, PTcor)", echo = TRUE, cache = TRUE, warning = FALSE>>=
#file dump
#add gene descriptions
prot_missingVal_desc <- cond_peps
gene_desc <- sapply(rownames(cond_peps), function(gene){try(orf2desc(unlist(strsplit(gene, split = '[/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- sapply(names(gene_desc)[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})], function(gene){try(orf2desc(unlist(strsplit(gene, split = '[-/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- "No Annotation"
rownames(prot_missingVal_desc) <- unname(gene_desc)

imput_abund_desc <- impute_abund
gene_desc <- sapply(colnames(imput_abund_desc), function(gene){try(orf2desc(unlist(strsplit(gene, split = '[/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- sapply(names(gene_desc)[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})], function(gene){try(orf2desc(unlist(strsplit(gene, split = '[-/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- "No Annotation"
colnames(imput_abund_desc) <- unname(gene_desc)

impute_abund_names <- colnames(impute_abund)
colnames(impute_abund) <- unname(sapply(colnames(impute_abund), function(x){strsplit(x, split = "/")[[1]][1]}))

if(unq_matches_only == TRUE){
write.output(prot_missingVal_desc, "run_Unq/mvMatrix.tsv")
write.output(uq_binPepMatrix[!(apply(uq_binPepMatrix != 0, 1, sum) %in% c(0,length(uq_binPepMatrix[1,]))),], "run_Unq/mvMatrixpeps.tsv")
write.output(t(imput_abund_desc), "run_Unq/relAbundMatrix_desc.tsv")
write.output(t(impute_abund), "run_Unq/relAbundMatrix.tsv")
write.output(t(shared_prot - shared_trans), "run_Unq/TPdiffMatrix.tsv")
save(n_prot, prot_abund, prot_prec, conditions, file = "run_Unq/protLMfile.Rdata")
}
if(unq_matches_only == FALSE){
write.output(prot_missingVal_desc, "run_Deg/mvMatrix.tsv")
write.output(uq_binPepMatrix[!(apply(uq_binPepMatrix != 0, 1, sum) %in% c(0,length(uq_binPepMatrix[1,]))),], "run_Deg/mvMatrixpeps.tsv")
write.output(t(imput_abund_desc), "run_Deg/relAbundMatrix_desc.tsv")
write.output(t(impute_abund), "run_Deg/relAbundMatrix.tsv")
write.output(t(shared_prot - shared_trans), "run_Deg/TPdiffMatrix.tsv")
write.output(t(shared_trans), "run_Deg/Trans_shared.tsv")
write.output(transcript_brauer, "run_Deg/Trans_all.tsv")
save(n_prot, prot_abund, prot_prec, conditions, file = "run_Deg/protLMfile.Rdata")
}
@






Determine how many clusters should be used for K-means clustering of protein abundance \& protein - transcript difference matrices.
<<kmeansNclust, dependson = "transHM", cache = TRUE>>=

kvals <- c(2:30)
data_clust <- stepFlexclust(t(impute_abund), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_prot <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})
	
data_clust <- stepFlexclust(t(shared_prot - shared_trans), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_pt <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})	
	
@

<<kmeanBarplot, dependson = "kmeansNclust", warning = FALSE, echo = FALSE>>=
plot_df <- data.frame(WICSSdiff = c(-1*diff(WICSS_prot), -1*diff(WICSS_pt)), nclusters = rep(kvals[-length(kvals)], times = 2), class = rep(c("Protein Abundance", "Protein - Transcript Abundance"), each = (length(kvals) - 1)))

clusterN_plot <- ggplot(plot_df, aes(x = nclusters, y = WICSSdiff)) + facet_grid(class ~ ., scales = "free_y")
clusterN_plot + geom_bar(stat = "identity")
@


Read in cluster assignments from Cluster2.0

<<prot_clust>>=

if(unq_matches_only == TRUE){
	prot_kmeans_ass <- read.delim("run_Unq/relAbundMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	prot_kmeans_ass <- read.delim("run_Deg/relAbundMatrix_K_G20.kgg")
	}

clusteredDat <- t(impute_abund)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(prot_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}
	
nclust <- length(unique(prot_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% prot_kmeans_ass[,1][prot_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	prot_kmeans_ass$GROUP[prot_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df1 <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}[h!]
<<protclustplot, dependson = "prot_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df1, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins in a cluster (teal) and the centroid itself (orange)}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in protein-abundance clusters}
\label{prot_FIRE}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/trans_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in transcript-abundance clusters}
\label{trans_FIRE}
\end{figure}


\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_iPAGE_GO.pdf}
\caption{iPAGE-GO output, performing gene-set enrichment analysis on protein-abundance clusters}
\label{prot_GO}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_iPAGE_KEGG.pdf}
\caption{iPAGE-KEGG output, searching for enrichment of metabolic processes in protein-abundance clusters}
\label{prot_KEGG}
\end{figure}


<<tn_clust>>=

if(unq_matches_only == TRUE){
	pt_kmeans_ass <- read.delim("run_Unq/TPdiffMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	pt_kmeans_ass <- read.delim("run_Deg/TPdiffMatrix_K_G20.kgg")
	}

clusteredDat <- t(shared_prot - shared_trans)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(pt_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}

n_c <- length(clusteredDat[1,])
nclust <- length(unique(pt_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% pt_kmeans_ass[,1][pt_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	pt_kmeans_ass$GROUP[pt_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df2 <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}
<<tnclustplot, dependson = "tn_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df2, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins - transcript differences; clusters (teal) and the centroid itself (orange)}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in protein-transcript difference clusters}
\label{TP_FIRE}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.4]{run_Deg/TPdiff_FIREpro.pdf}
\caption{FIRE-prot output, searching for enrichment of amino acid motifs in the primary sequence of proteins within protein-transcript difference clusters}
\label{TP_FIREpro}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_iPAGE_GO.pdf}
\caption{iPAGE-GO output, performing gene-set enrichment analysis on protein-transcript difference clusters}
\label{TP_GO}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_iPAGE_KEGG.pdf}
\caption{iPAGE-KEGG output, searching for enrichment of metabolic processes in protein-abundance clusters}
\label{TP_KEGG}
\end{figure}


\clearpage

\section*{Looking for condition and growth-rate specific changes in protein abundance}

<<regSumImport>>=
#using the protLMfile files saved, cond_trend_regressions.R is run

load("protRegressions.Rdata")
n_bs_t <- 5000
n_bs_f <- 1000
FDR_desired <- 0.05
@


Two types of models were fitted to each protein's relative abundance across the 25 conditions.  

\textcolor{blue}{\circled{1}} \textbf{Fitting a condition-specific slope and intercept and testing whether $\beta/\alpha$ != 0 using a pivotal t-statistic approach.}

\begin{equation}
y_{i} = \beta^c \cdot DR_{i} + \alpha^c + \epsilon_{i}
\end{equation}

<<protSum1, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$prot_tstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Protein variation analyzed with t-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\textcolor{blue}{\circled{2}} \textbf{An F-statistic based approach to compare nested models}

Test condition-specific differences in offset (one condition has a different offset from all others)
\begin{align}
H_{1} &= \beta \cdot DR_{i} + \alpha^{c/-c} + \epsilon_{i}\\
H_{0} &= \beta \cdot DR_{i} + \alpha + \epsilon_{i}
\end{align}

Test for condition-specific slope (one condition has a different slope from all others)
\begin{align}
H_{1} &= \beta^{c/-c} \cdot DR_{i} + \alpha^c + \epsilon_{i}\\
H_{0} &= \beta \cdot DR_{i} + \alpha^c + \epsilon_{i}
\end{align}

<<protSum2, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$prot_Fstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Protein variation analyzed with F-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\clearpage
The same procedure was used on the divergent peptides

<<protSum3, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$divpep_tstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Divergent peptide variation analyzed with t-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

<<protSum4, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$divpep_Fstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Divergent peptide variation analyzed with F-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\subsection*{Investigating specific examples of protein patterns departing from transcriptional patterns}

\textbf{Starting by looking at the best versus the worst, in terms of protein(peptide) patterns}

<<badCorrCompare1, dependson = "PTcor">>=
dispartecors <- sort(pt_corrs$correlation)[c(1:10,length(pt_corrs[,1]):(length(pt_corrs[,1]) - 9))]
gene_index <- order(pt_corrs$correlation)[c(1:10,length(pt_corrs[,1]):(length(pt_corrs[,1]) - 9))]

prot_abundMatchedIndex <- sapply(colnames(shared_prot)[gene_index], function(match_it){c(1:length(prot_abund_final[1,]))[colnames(prot_abund_final) == match_it]})

@

\begin{figure}[h!]
<<dispProtPlot, dependson = c("badCorrCompare1", "protPlot1"), warning = FALSE>>=
source("pep_library.R")

plot_protein_lattice(prot_abundMatchedIndex, possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 5)
@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}


\begin{figure}[h!]
<<dispProtScatter, dependson = c("badCorrCompare1", "setup")>>=
shared_prot_tmp <- shared_prot[,gene_index]; shared_trans_tmp <- shared_trans[,gene_index]
colnames(shared_prot_tmp) <- colnames(shared_trans_tmp) <- unname(orf2common(colnames(shared_prot)[gene_index]))
  
divCompDf <- cbind(melt(shared_prot_tmp), melt(shared_trans_tmp)[,3])
colnames(divCompDf) <- c("condition", "gene", "Protein_Abundance", "Transcript_Abundance")
divCompDf$limitation <- sapply(as.character(divCompDf$condition), function(el){strsplit(el, split = "")[[1]][1]})
divCompDf$gene <- factor(divCompDf$gene, levels = colnames(shared_prot_tmp))

divScatterPlot <- ggplot(divCompDf, aes(x = Transcript_Abundance, y = Protein_Abundance, col = factor(limitation))) + facet_wrap(~ gene, ncol = 5, scales = "free")
print(divScatterPlot + geom_point())
@
\caption{Comparison of the transcriptional versus protein relative abundance patterns for the most poorly-correlated and well-correlated examples}
\end{figure}

Poorly correlated tend to have very little change across conditions, so signal:noise is lower.\\
well correlated tend to have many more peptides measured - plot number of peptides versus correlation or mean(precision) versus correlation


\textbf{Do continuous GO on the spearman correlation}
%<<>>=
%entrez_pt_corrs <- pt_corrs; rownames(entrez_pt_corrs) <- orf2entrez(colnames(shared_prot))
%write.table(entrez_pt_corrs, file = "run_Deg/spearmanCorr.tsv", sep = "\t", row.names = TRUE, col.names = TRUE, quote = FALSE)
%run Arjun python script
%@

<<gseaCorrMF>>=
gseaCorrMF <- read.table('contGSEA/spearmanCorr-gobp_yeast.closed.zscore.mat', sep = "\t", header = TRUE)
gseaCorrMotif <- read.table('contGSEA/spearmanCorr-interpro_yeast_entrez.zscore.mat', sep = "\t", header = TRUE)

@


%<<GSEA_corr_MF, include = FALSE>>=
%nbreaks = 100
%hist(gseaCorrMF[,4], breaks = nbreaks, main = "GSEA Z-scores versus null expectation", xlab = "Z scores (Wald statistics)")
%lines(dnorm(seq(range(gseaCorrMF[,4])[1], range(gseaCorrMF[,4])[2], by=diff(range(gseaCorrMF[,4]))/1000), 0, 1)*length(gseaCorrMF[,1])*diff(range(gseaCorrMF[,4]))/nbreaks ~ seq(range(gseaCorrMF[,4])[1], range(gseaCorrMF[,4])[2], by=diff(range(gseaCorrMF[,4]))/1000), lwd =3, col = "BLUE")
% @

\begin{figure}[h!]
\centering
\includegraphics[scale = 0.8]{figure/GSEA_corr_MF.pdf}
\caption{PAGE analysis of spearman correlations between patterns of protein and transcript relative variation for the the same genes - negative scores indicate enrichment of a gene-set within more-negative spearman correlations and positive suggests an association with greater positive-correlations.  The histogram indicates the actual distribution of GO-term Z-scores and the curve indicates the null expectati that these values will follow a N(0,1) distribution}
\label{GSEA_PTcorrDat}
\end{figure}

\section*{Interesting notes and representative examples}

\begin{itemize}
\item[YGL009C: LEU1] - up in leucine limitation and one-peptide is down (consistent with an increase in phosphorylation)
\item[YGR253C: PUP2] - 20S proteasome involved in ubiquitin-dependent catabolism - one peptide is very high in low Nitrogen-lim and high in Leucine-lim.
\item[on FIRE] FIRE detects a substantial number of transcriptional regulatory motifs in the proteomics (figure \ref{prot_FIRE}) and transcriptional datasets.  This is contrasted with paucity of protein motifs (none).  This trend is reversed when looking at patterns in the ratio of Protein/Transcript, where there are few transcriptional motifs (figure \ref{TP_FIRE}) and many protein motifs (figure \ref{TP_FIREpro}). 	
\end{itemize}
\end{document}  
