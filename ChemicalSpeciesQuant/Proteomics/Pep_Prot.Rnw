\documentclass[12pt]{article}
\usepackage[left=0.95in,top=0.95in,right=0.95in,bottom=0.95in,nohead]{geometry}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{wrapfig}	%in-line figures
\usepackage[numbers, super]{natbib}		%bibliography
%\usepackage{pslatex} 	%for times new roman
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{aurical}
\usepackage[T1]{fontenc}
\usepackage[scaled]{helvet}
\usepackage{multicol}

\Sexpr{opts_chunk$set(tidy=TRUE, message=FALSE)}
<<echo=FALSE,results='hide'>>=
options(width=80)
library(knitr)

setwd('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics')
load('20120807ProtPepMatrices.Rdata')
source("pep_library.R")
plotting_fxn()
matrix_fxn()
library(ggplot2)
library(flexclust)

@


\author{Sean R. Hackett}
\title{Peptides to Protein EM and analysis} 
\date{}

\begin{document}

\setlength{\parskip}{0.5mm}
\linespread{1}

\thispagestyle{empty}
\pagestyle{empty}

\maketitle


\section*{Data Processing}

\small

<<dataImp, cache=TRUE>>=

quality_frac <- 0.8
ICthreshold <- 2^15
#only consider peptides that match unambiguously to a single protein
unq_matches_only <- FALSE

lightIC[lightIC < ICthreshold] <- NA; heavyIC[heavyIC < ICthreshold] <- NA

good_samples <- rowSums(is.finite(PepMatrix) & !is.na(lightIC) & !is.na(heavyIC)) >= (length(PepMatrix[1,])*quality_frac)

#possible mappings between a protein and all matching peptides
mappingMat <- ProtPepMatrix[good_samples,]
nsharedpep <- table(rowSums(mappingMat))

if(unq_matches_only){
	good_samples[good_samples] <- good_samples[good_samples] & (rowSums(mappingMat) == 1)
	mappingMat <- ProtPepMatrix[good_samples,]
	}
mappingMat <- mappingMat[,colSums(mappingMat) != 0]

#the relative abundance of a peptide across conditions w.r.t a common reference
abundMat <- PepMatrix[good_samples,]
good_light <- lightIC[good_samples,]
good_heavy <- heavyIC[good_samples,]

#map measured peaks to unique peptide sequences

pepNames <- rownames(mappingMat)
unique_NameCorr <- sapply(pepNames, function(name){
	unlist(strsplit(name, "\\."))[1]
	})
unique_pepNames <- unique(unique_NameCorr)
unique_NameCorrCol <- sapply(unique_NameCorr, function(name){
	c(1:length(unique_pepNames))[name == unique_pepNames]
	})

pepToUniq <- matrix(0, nrow = length(pepNames), ncol = length(unique_pepNames))
rownames(pepToUniq) <- pepNames; colnames(pepToUniq) <- unique_pepNames
for(i in 1:length(pepNames)){
	pepToUniq[i,unique_NameCorrCol[i]] <- 1
	}
pepToUniq <- Matrix(pepToUniq)

#determine the expectation of the standard deviation as a heteroschedastic fxn of IC using p0.05 light v. p0.05 heavy

avgSignalSTD <- apply(cbind(heavyIC[,colnames(heavyIC) == "P0.05"], lightIC[,colnames(lightIC) == "P0.05"]), 1, mean)
logLight <- log2(lightIC[is.finite(avgSignalSTD),colnames(lightIC) == "P0.05"])
logHeavy <- log2(heavyIC[is.finite(avgSignalSTD),colnames(heavyIC) == "P0.05"])
avgSignalSTD <- avgSignalSTD[is.finite(avgSignalSTD)]
#remove this step to increase variance, since this factor isnt known in principle
logLight <- logLight + optimize(normFactor, c(-1, 1), logLight = logLight, logHeavy = logHeavy)$minimum

#variance of the replicate differences accounting for small sample (scaling factor of 2)
STDvar <- (logLight - logHeavy)^2*2
STDvar_fit <- lm(log2(STDvar) ~ log2(avgSignalSTD))$coef



@

\normalsize

\begin{figure}[h!]
<<nshare, dependson = "dataImp", echo = FALSE>>=
barplot(nsharedpep)
@
\caption{Number of proteins that a measured peptide matches}
\end{figure}

\begin{itemize}
\item Remove all peptides with more than \Sexpr{1 - quality_frac} fraction of missing data
\item Remove all peptides with less than \Sexpr{ICthreshold} ions measured
\item This results in \Sexpr{table(good_samples)[names(table(good_samples)) == TRUE]} peptides that are retained and \Sexpr{table(good_samples)[names(table(good_samples)) == FALSE]} peptides which are discarded.
\end{itemize}

In order to determine the expected variance of the relative abundance of a peptide($\mathbf{X}_{ic}$ about the relative abundance of its corresponding protein ($\mathbf{\Omega}_{kc}$), we assume that $\mathbf{X}_{ic} \sim N(\mathbf{\Omega}_{kc}, \sigma^{2}_{ic}$) with $E[\sigma^{2}_{ic}]$ being fitted either from residuals or replicates.

Fitting from replicates can be done because all of the samples are quantified with respect to a common reference p0.05, including an experimental sample of p0.05.  The difference between these  

\begin{figure}[h!]
<<repdiffplot1, dependson = "dataImp", echo = FALSE>>=
gplot.hexbin(hexbin(logLight, logHeavy, xbins = 200), colramp = rainbow)
@
\label{heavylightcomp}
\caption{Comparison of log$_{2}$p0.05$^{H}$ and log$_{2}$p0.05$^{L}$}
\end{figure}

<<repdiffplot2, dependson = "dataImp", label = "ICsdreg1", echo = FALSE, include = FALSE>>=
plot(log2(STDvar) ~ log2(avgSignalSTD), pch = 16, cex = 0.3)
abline(STDvar_fit, col = "RED")
@

<<repdiffplot3, dependson = "dataImp", label = "ICsdreg2", echo = FALSE, include = FALSE>>=
gplot.hexbin(hexbin(log2(avgSignalSTD), log2(STDvar), xbins = 80), colramp = rainbow)
@


\begin{figure}[h!]
\begin{center}
\subfloat[Linear regression]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg1.pdf}
}
\qquad
\subfloat[Bivariate histogram: residual variance is a decreasing function of signal strength]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg2.pdf}}
\end{center}
\label{repFitSD1}
\caption{$\epsilon^{2}$ versus average log$_{2}$ ion counts of the heavy and light peak}
\end{figure}





\small

<<EMsetup, dependson = "dataImp", cache = TRUE>>=

#calculate the expected sampling variance of the heavy-low diff for experimental measurement

lightHeavyCellmean <- sapply(c(1:length(heavyIC[,1]))[good_samples], function(row){
	mapply(FUN = function(a,b){
		if(!is.na(a) & !is.na(b)){mean(a, b)}else{NA}
		}, lightIC[row,], heavyIC[row,])
	})

fittedVar <- var_calc(lightHeavyCellmean, STDvar_fit)
fittedPrec <- fittedVar^-1

#for each unique peptide, combine the multiple ionization states to produce a single point estimate, using integrated likelihood

#set the precision of missing values to 0; equivalent to no impact, infinite variance

fittedPrec[t(is.na(abundMat))] <- 0
fittedPrec[is.na(fittedPrec)] <- 0
abundMat[t(fittedPrec) == 0] <- 0

n_p = length(unique_pepNames) #4042
n_prot <- length(mappingMat[1,])
n_pp = n_p + n_prot #4964
n_c = length(abundMat[1,]) #15

uniquePepMean <- matrix((((t(abundMat) * fittedPrec) %*% pepToUniq)/(fittedPrec %*% pepToUniq)), ncol = n_p, nrow = n_c)
uniquePepPrecision <- Matrix(fittedPrec %*% pepToUniq)
uniquePepMean[is.nan(uniquePepMean)] <- NA

#change mapping from peptides to unique peptides (averaging over ionization states)
unique_mappingMat <- as.matrix(t(pepToUniq) %*% mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)


#number of non-missing values for peptides
Nmissing_val <- table(rowSums(!is.na(t(uniquePepMean))))

uniquePepMean[is.na(uniquePepMean)] <- 0

#number of non-missing values for all peptides (before uniquenss combination)
Nmissing_val_all <- table(apply(is.finite(PepMatrix), 1, sum))

@

\begin{figure}[h!]
<<mvbarplot, dependson = "EMsetup", echo = FALSE>>=
barplot(table(apply(is.finite(PepMatrix), 1, sum)), col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val_all)) < ceiling(n_c * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val_all)) >= ceiling(n_c * quality_frac)))))
@
\caption{Distribution of non-missing values for all peptides.  Peptides with non-missing values over the cutoff are shown in orange}
\label{nonmissingvals}
\end{figure}

<<mvmat, dependson = "EMsetup", cache = TRUE>>=

#look at structure in the missing values
binPepMatrix <- ifelse(is.finite(lightIC), 1, 0)

pnonmissingOverSingles <- matrix(NA, ncol = length(binPepMatrix[1,]), nrow = length(binPepMatrix[1,]))
rownames(pnonmissingOverSingles) <- colnames(binPepMatrix); colnames(pnonmissingOverSingles) <- colnames(binPepMatrix)
pnonmissingOverTotal <- pnonmissingOverSingles
for(i in 1:length(pnonmissingOverSingles[1,])){
	for(j in 1:length(pnonmissingOverSingles[1,])){	
	pnonmissingOverTotal[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2)/length(binPepMatrix[,1])
  	pnonmissingOverSingles[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2) / sum(apply(binPepMatrix[,c(i, j)], 1, sum) > 0)
	}
}

@

<<mvplot1, dependson = "mvmat", label = "missingOverlap1", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverTotal, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

<<mvplot2, dependson = "mvmat", label = "missingOverlap2", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverSingles, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2yellow(100), dendrogram = "none")
@

\begin{figure}[h!]
\begin{center}
\subfloat[p(A $\cap$ B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap1}
}
\qquad
\subfloat[A $\cap$ B / max(A, B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap2.pdf}}
\end{center}
\label{repFitSD2}
\caption{Overlap of missing ascertained peptides across conditions}
\end{figure}

<<mvmat_red, dependson = "mvmat">>=
uq_ProtPepMatrix <- ProtPepMatrix[rowSums(ProtPepMatrix) == 1,]
uq_binPepMatrix <- binPepMatrix[rowSums(ProtPepMatrix) == 1,]

cond_peps <- t(((t(uq_binPepMatrix) %*% uq_ProtPepMatrix) != 0)*1)
cond_peps <- cond_peps[!(rowSums(cond_peps) %in% c(0, length(cond_peps[1,]))),]

blackOrange <- function (n){colorpanel(n, "black", "black", "orange")}

@

\begin{figure}[h!]
<<misval_HM, dependson = "mvmat_red", echo = FALSE, warning = FALSE>>=
man_dist <- function(x){dist(x, method = "manhattan")}
heatmap.2(cond_peps, Rowv = TRUE, Colv = FALSE, trace = "none", col=blackOrange(100), distfun = man_dist, cexRow = 0.1)
@
\caption{hierarchical clustering of proteins missing in a subset of conditions using manhattan distance}
\end{figure}

<<cluster_misval, dependson = "mvmat_red", cache = TRUE>>=

#kvals <- c(2:20)
#data_clust <- stepFlexclust(cond_peps, k = kvals, nrep=20, verbose=FALSE, FUN = kcca, family = kccaFamily(which = "kmedians"))


#WICSS <- sapply(1:length(kvals), function(k_num){
#	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
#	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
#	})
	
#k_clust_misVal <- kvals[WICSS/WICSS[1] < 0.4][1]
k_clust_misVal <- 5

mv_clust <- stepFlexclust(cond_peps, k = k_clust_misVal, nrep=100, verbose=FALSE, FUN = kcca, family = kccaFamily(which = "kmedians"))

clust_counts1 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)
clust_counts0 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)

for(kval in 1:k_clust_misVal){
	binsub <- cond_peps[mv_clust@cluster == kval,]
	clust_counts1[kval,] <- colSums(binsub)
	clust_counts0[kval,] <- length(binsub[,1]) - colSums(binsub)
	}
clust_ypos_adj <- matrix(5*rep(0:(k_clust_misVal-1), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_xpos <- matrix(rep(1:n_c, times = k_clust_misVal), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_num <- matrix(rep(1:(k_clust_misVal), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)

clust_plot_df <- data.frame(condition = c(c(clust_xpos), c(clust_xpos)), cluster_val = c(c(1 + clust_ypos_adj), c(clust_ypos_adj)),counts = c(c(clust_counts1), c(clust_counts0)), shape = as.factor(c(c(clust_num), c(clust_num))), medianoid = as.factor(c(c(mv_clust@centers), c(1 - mv_clust@centers))))

@

\begin{figure}[h!]
<<plot_missingvalClusters, dependson = "cluster_misval", echo = FALSE>>=
clust_plot <- ggplot(clust_plot_df, aes(x = condition, y = cluster_val, size = counts, color = medianoid))
clust_plot <- clust_plot + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
clust_plot + geom_point()
@
\end{figure}

<<GSEA_prep, cache = TRUE>>=
library(GSEABase)
library(org.Sc.sgd.db)

frame = toTable(org.Sc.sgdGO)

goframeData = data.frame(frame$go_id, frame$Evidence, frame$systematic_name)
goFrame=GOFrame(goframeData,organism="Saccharomyces cerevisiae")
goAllFrame=GOAllFrame(goFrame)
gsc <- GeneSetCollection(goAllFrame, setType = GOCollection())
@

<<perform_GSEA, dependson= c("GSEA_prep", "cluster_misval")>>=
library(methods)
library(GOstats)
library(GSEABase)
FDR = .05

#MF - molecular function, BP - biological process, CC cellular component
GSEA.test = function(genes, category) {
	universe = rownames(cond_peps)
	
	params <- GSEAGOHyperGParams(name="GSEA for Bar-Seq data",
		geneSetCollection=gsc,
		geneIds = genes,
		universeGeneIds = universe,
		ontology = category,
		pvalueCutoff = 1,
		conditional = FALSE,
		testDirection = "over")
	hyperGTest(params)
	}

#save(mv_clust, GSEA.test, cond_peps, file = "GSCAclust.Rdata")

sum_list <- list()

for(kval in 1:k_clust_misVal){
	test <- names(mv_clust@cluster[mv_clust@cluster == kval])
	go_sum <- summary(GSEA.test(test, "MF"))
	sum_list$MF[[kval]] <- go_sum[go_sum$Pvalue < 0.01,]
	go_sum <- summary(GSEA.test(test, "BP"))
	sum_list$BP[[kval]] <- go_sum[go_sum$Pvalue < 0.01,]
	go_sum <- summary(GSEA.test(test, "CC"))
	sum_list$CC[[kval]] <- go_sum[go_sum$Pvalue < 0.01,]
	}


xtable(sum_table)

@

<<GSEAtable, dependson = "perform_GSEA", results = "tex">>=
library(stable)
sum_table <- NULL
for(kval in 1:k_clust_misVal){
	test <- names(mv_clust@cluster[mv_clust@cluster == kval])
	for(ont in c("MF", "BP", "CC")){
		go_sum <- summary(GSEA.test(test, ont)
		sum_table <- rbind(sum_table, cbind(k = oval, category = not, go_sum[go_sum$Pvalue < 0.01,]))
	}
xtable(sum_table)
@


\clearpage
\section*{Going from peptides to proteins via expectation-maximization}

When using relative variation in peptides to predict variation in protein abundance we need to deal with two factors
\begin{itemize}
\item If a peptide maps to multiple proteins, it should be attributed to a protein (thereby adding signal) to the extent that its pattern matches the pattern from other peptides.
\item Some peptides won't conform to the trends of their protein because they may be the non-covalently modified complement of a set of unascertained modified peptides.  These peptides shouldn't inform the general protein trend, and may be interesting to analyze in isolation.
\end{itemize}sum_list

\subsection*{Algorithm structure}

\begin{itemize}
\item[\textbf{X}:] [I $\cdot$ C] Data matrix: Input MS data of the relative abundance of each peptide across C conditions
\item[\textbf{M}:] [I $\cdot$ J] Possible mappings between peptides (I) and proteins (J)
\item[$\mathbf{\Theta}$:] [I $\cdot$ K] Responsibility matrix: prob that peptide i belongs to protein j or shows a divergent trend which should be described separately.  K = I + J
\item[$\mathbf{\Omega}$:] [K $\cdot$ C] Point estimate for each species$\cdot$condition.
\item[$\sigma^{2}$:] [I] Fitted variance relative to peptide IC.
\end{itemize}

\begin{align}
p(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &\propto \prod_{i}^{I}\prod_{c}^{C} \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i}) \cdot \mathbf{\Theta}p(\mathbf{\Theta})\notag\\
\textit{l}(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &= \sum_{i}^{I}\sum_{c}^{C} \textit{ln}\left( \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i})\right)\notag\\
+ \sum_{i}^{I}\sum_{k}^{K}\mathbf{\Theta_{ik}}p(\mathbf{\Theta_{ik}})
\end{align}


\subsection{Updating $\mathbf{\Theta}$}

\begin{align}
\mathbf{\Theta}_{ik} \sim \frac{\textbf{N}(\mathbf{\Omega}_{kC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ik})}{\sum_{b = 1}^{K}\textbf{N}(\mathbf{\Omega}_{bC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ib})}
\end{align}

\subsection{Updating $\mathbf{\Omega}$}

$\tau_{y} = \prod_{z \neq y}^{Y}\sigma^{2}_{z}$

\begin{align}
\mathbf{\Omega}_{kc} \sim \mbox{\Large \textbf{N}}\left(\mu = \frac{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\textbf{X}_{ic}\tau_{i}}{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\tau_{i}}, \sigma^{2} =  \left(\sum_{i = 1}^{I}\frac{\mathbf{\Theta}_{ik}}{\sigma^{2}_{i}}\right)^{-1} \right)
\end{align}

\subsection*{Algorithm Implementation}


\end{document}  
