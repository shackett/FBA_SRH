\documentclass[12pt]{article}
\usepackage[left=0.5in,top=0.5in,right=0.5in,bottom=0.5in,nohead]{geometry}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{wrapfig}	%in-line figures
\usepackage[numbers, super]{natbib}		%bibliography
%\usepackage{pslatex} 	%for times new roman
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{aurical}
\usepackage[scaled]{helvet}
\usepackage{multicol}
\usepackage{upquote}
\usepackage{tikz}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\Sexpr{opts_chunk$set(tidy=TRUE, message=FALSE)}
<<setup, echo=FALSE,results='hide'>>=
options(width=80, stringsAsFactors = FALSE)
library(knitr)

opts_knit$set(progress = TRUE, verbose = TRUE)
opts_chunk$set(echo = FALSE)


setwd('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics')
load('20130313ProtPepMatrices.Rdata')
proteomicsBlocking <- read.table("proteomicsBlocking.tsv", header = TRUE)
source("pep_library.R")
plotting_fxn()
matrix_fxn()

blackOrange <- function(n){colorpanel(n, "black", "black", "orange")}
greenBlackRed <- function(n){colorpanel(n, "green", "black", "red")}

library(ggplot2)
library(xtable)

@


\author{Sean R. Hackett}
\title{Peptides to Protein EM (Aggregator) and analysis} 
\date{}

\begin{document}
\SweaveOpts{concordance=TRUE}

\setlength{\parskip}{0.5mm}
\linespread{1}

\thispagestyle{empty}
\pagestyle{empty}

\maketitle


\section*{Data Processing}

\small

<<dataImp, cache=TRUE>>=

quality_frac <- 0.1
ICthreshold <- 2^15
#only consider peptides that match unambiguously to a single protein
unq_matches_only <- FALSE


lightIC[lightIC < ICthreshold] <- NA; heavyIC[heavyIC < ICthreshold] <- NA

#filter experimental column from instruments without an biological replicates
good_experimental_samples <- colnames(lightIC) %in% proteomicsBlocking$SampleName[proteomicsBlocking$Instrument %in% c("QTOF6538", "QTOF6550")]
lightIC <- lightIC[,good_experimental_samples]; heavyIC <- heavyIC[,good_experimental_samples]; PepMatrix <- PepMatrix[,good_experimental_samples]; peptideSN <- peptideSN[,good_experimental_samples]
proteomicsBlocking <- proteomicsBlocking[good_experimental_samples,]

#filter samples with too many missing values (below threshold)
good_samples <- rowSums(is.finite(PepMatrix) & !is.na(lightIC) & !is.na(heavyIC)) >= (length(PepMatrix[1,])*quality_frac)

#possible mappings between a protein and all matching peptides
mappingMat <- ProtPepMatrix[good_samples,]
nsharedpep <- table(rowSums(mappingMat))

if(unq_matches_only){
	good_samples[good_samples] <- good_samples[good_samples] & (rowSums(mappingMat) == 1)
	mappingMat <- ProtPepMatrix[good_samples,]
	}
mappingMat <- mappingMat[,colSums(mappingMat) != 0]

#combine degenerate proteins together if all the peptides associated with multiple proteins are shared

degen_prots <- apply(mappingMat, 2, function(prot){
	paste(prot, collapse = "")
	})

degen_prot_patterns <- names(table(degen_prots))[unname(table(degen_prots)) > 1]

degen_prot_matches <- list()
degen_mappings <- NULL
for(pat in 1:length(degen_prot_patterns)){
	
	degen_prot_matches[[paste(colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]], collapse = "/")]] <- colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]]
	degen_mappings <- cbind(degen_mappings, mappingMat[,degen_prots %in% degen_prot_patterns[pat]][,1])
	
	}
colnames(degen_mappings) <- names(degen_prot_matches)	

mappingMat <- cbind(mappingMat[,!(degen_prots %in% degen_prot_patterns)], degen_mappings)	
	


#the relative abundance of a peptide across conditions w.r.t a common reference
abundMat <- PepMatrix[good_samples,]
abundMat[is.infinite(abundMat)] <- NA

good_light <- lightIC[good_samples,]
good_heavy <- heavyIC[good_samples,]
good_SN <- peptideSN[good_samples,]

#map measured peaks to unique peptide sequences

pepNames <- rownames(mappingMat) # the same peptide with different charge states and possible methionine oxidation
unique_NameCorr <- sapply(pepNames, function(name){
	unlist(strsplit(name, "\\."))[1]
	})

#### Collapsing charge states #####

unique_pepNames <- unique(unique_NameCorr) # unique peptides over charge states
unique_NameCorrCol <- sapply(unique_NameCorr, function(name){
	c(1:length(unique_pepNames))[name == unique_pepNames]
	})
pepToUniq <- matrix(0, nrow = length(pepNames), ncol = length(unique_pepNames))
rownames(pepToUniq) <- pepNames; colnames(pepToUniq) <- unique_pepNames
for(i in 1:length(pepNames)){
	pepToUniq[i,unique_NameCorrCol[i]] <- 1
	}
pepToUniq <- Matrix(pepToUniq) #mapping matrix between all charge states and unique peptides


#### Collapsing methionine oxidations ####

oxPeptides <- pepNames[grep('m', pepNames)] #peptides where methionine was oxidized
oxPeptides <- oxPeptides[gsub('m', 'M', oxPeptides) %in% pepNames] #peptides which have a non-oxidized parent peptide
unique_pepNamesM <- pepNames[!(pepNames %in% oxPeptides)]

pepToUniqM <- Matrix(diag(length(pepNames))[,!(pepNames %in% oxPeptides)])
rownames(pepToUniqM) <- pepNames; colnames(pepToUniqM) <- unique_pepNamesM

for(oxPeptide in oxPeptides){
  pepToUniqM[pepNames == oxPeptide, unique_pepNamesM == gsub('m', 'M', oxPeptide)] <- 1
  }


######## how similar are relative abundances from the same peptide with different charge states or methionine oxidation ######

chargeComp <- pepToUniq[,colSums(pepToUniq) > 1]
chargeCompStack <- sapply(1:length(chargeComp[1,]), function(x){
    charge_matches <- cor(t(abundMat[chargeComp[,x] == 1,]), use = "pairwise.complete.obs")
    present_data = 1 * !is.na(abundMat[chargeComp[,x] == 1,])
    charge_matches[lower.tri(charge_matches, diag = FALSE) & (present_data %*% t(present_data)) > 20]
    })

oxComp <- pepToUniqM[,colSums(pepToUniqM) > 1]
oxCompStack <- sapply(1:length(oxComp[1,]), function(x){
    ox_matches <- cor(t(abundMat[oxComp[,x] == 1,]), use = "pairwise.complete.obs")
    present_data = 1 * !is.na(abundMat[oxComp[,x] == 1,])
    ox_matches[lower.tri(ox_matches, diag = FALSE) & (present_data %*% t(present_data)) > 20]
    })  
  
combined_charge_ox <- rbind(data.frame(comparison = "chargeStates", correlation = unlist(chargeCompStack)), data.frame(comparison = "methionineOxidation", correlation = unlist(oxCompStack)))

#hist(apply(log2(lightIC[grep('m', rownames(lightIC)),]), 1, mean, na.rm = TRUE))
#hist(apply(log2(lightIC[grep('m', rownames(lightIC), invert = TRUE),]), 1, mean, na.rm = TRUE))

#### Collapsing methionine oxidations after charge collapse ####

oxPeptides <- unique_pepNames[grep('m', unique_pepNames)] #peptides where methionine was oxidized
oxPeptides <- oxPeptides[gsub('m', 'M', oxPeptides) %in% unique_pepNames] #peptides which have a non-oxidized parent peptide
unique_pepNamesM <- unique_pepNames[!(unique_pepNames %in% oxPeptides)]

pepToUniqM <- Matrix(diag(length(unique_pepNames))[,!(unique_pepNames %in% oxPeptides)])
rownames(pepToUniqM) <- unique_pepNames; colnames(pepToUniqM) <- unique_pepNamesM

for(oxPeptide in oxPeptides){
  pepToUniqM[unique_pepNames == oxPeptide, unique_pepNamesM == gsub('m', 'M', oxPeptide)] <- 1
  }


#determine the expectation of the standard deviation as a heteroschedastic fxn of IC using p0.05 light v. p0.05 heavy

refSamples <- proteomicsBlocking[proteomicsBlocking$Condition == "p0.05",]
# generate an instrument-specific function
bioRepPlot <- NULL
for(inst in unique(refSamples$Instrument)){
  logLight = data.frame(log2(lightIC[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]]))
  logHeavy = data.frame(log2(heavyIC[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]]))
  pepSN = data.frame(peptideSN[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]])
  avgSignalSTD <- data.frame((logLight + logHeavy)/2)
  
  for(a_sample in 1:length(refSamples$SampleName[refSamples$Instrument == inst])){
    logLight_redvec = logLight[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    logHeavy_redvec = logHeavy[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    avgSignal_redvec = avgSignalSTD[is.finite(avgSignalSTD[,a_sample]),a_sample]
    logLight_redvec <- logLight_redvec + optimize(normFactor, c(-1, 1), logLight = logLight_redvec, logHeavy = logHeavy_redvec)$minimum
    SN_redvec <- pepSN[is.finite(avgSignalSTD[,a_sample]),a_sample]
    
    bioRepPlot <- rbind(bioRepPlot, data.frame(experimental = logLight_redvec, reference = logHeavy_redvec, averageIC = avgSignal_redvec, variance = (logLight_redvec - avgSignal_redvec)^2*2,Instrument = inst, Set = refSamples$Set[refSamples$Instrument == inst][a_sample], SN = SN_redvec ))
    
    }
  }

@

\begin{itemize}
\item Remove all peptides with more than \Sexpr{(1 - quality_frac)*100}\% missing data
\item Remove all peptides with less than \Sexpr{ICthreshold} ions measured
\item This results in \Sexpr{table(good_samples)[names(table(good_samples)) == TRUE]} peptides that are retained and \Sexpr{table(good_samples)[names(table(good_samples)) == FALSE]} peptides which are discarded.
\end{itemize}

Some of the proteins are totally degenerate, i.e. all of the peptides that match them, also match one or more other effectively identical proteins.  To deal with this, These degenerate proteins were combined and the mapping matrix (of peptides - proteins) was consolidated removing these degeneracies, the degenerate proteins were then combined and named according to the genes that they encompass.  These proteins shouldn't be used for transcript $\sim$ protein association, but will be useful for other purposes.

\begin{figure}[h!]
<<repdiffplot1, dependson = "dataImp", echo = FALSE, cache = TRUE>>=

hex_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "aliceblue"), legend.position = "top", strip.background = element_rect(fill = "cornflowerblue"), strip.text = element_text(color = "cornsilk"), panel.grid.minor = element_blank(), panel.grid.major = element_blank(), axis.line = element_blank(), legend.key.width = unit(6, "line")) 

LHscatter <- ggplot(bioRepPlot, aes(y = experimental, x = reference)) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("log2 N-15 labelled p0.05", expand = c(0.02,0.02)) + scale_y_continuous("log2 Unlabelled p0.05", expand = c(0.01,0.01)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7))
LHscatter + geom_hex(bins = 200)

SNscatter <- ggplot(bioRepPlot, aes(y = experimental - reference, x = log2(SN))) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_fill_gradientn(name = "Counts", colours = rainbow(7)) + scale_x_continuous("log2 Signal:noise of H/L measurement", expand = c(0.02,0.02), limit = c(-10, 20)) + scale_y_continuous("H - L log2 p0.05 abundance", expand = c(0.01,0.01), limit = c(-10,10))
SNscatter + geom_hex(bins = 100)
@
\label{heavylightcomp}
\caption{Comparison of log$_{2}$p0.05$^{H}$ and log$_{2}$p0.05$^{L}$}
\end{figure}

<<ICsdreg1, dependson = "dataImp", echo = FALSE, include = FALSE, cache = TRUE>>=

LHresiduals <- ggplot(bioRepPlot, aes(x = averageIC, y = log2(sqrt(variance)))) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("average log2 H/L IC", expand = c(0.02,0.02)) + scale_y_continuous("log2 sd between log2 H/L IC ", expand = c(0.01,0.01), limits = c(-10, 5)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7)) 
LHresiduals + geom_hex(bins = 60) + geom_smooth(method = "lm", formula = y ~ x, fill = "cornflowerblue", color = "cornsilk")
@

<<MAplot, dependson = "dataImp", echo = FALSE, include = FALSE, cache = TRUE>>=

MAplot <- ggplot(bioRepPlot, aes(x = averageIC, y = experimental - reference)) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("average log2 H/L IC", expand = c(0.02,0.02)) + scale_y_continuous("log2 L - H", expand = c(0.01,0.01), limits = c(-10, 10)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7)) 
MAplot + geom_hex(bins = 150) + geom_smooth(method = "lm", formula = y ~ x, fill = "cornflowerblue", color = "cornsilk")
@


\begin{figure}[h!]
\begin{center}
\subfloat[Linear regression]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg1.pdf}
}
\qquad
\subfloat[Bivariate histogram: residual variance is a decreasing function of signal strength]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg2.pdf}}
\end{center}
\label{repFitSD1}
\caption{$\epsilon^{2}$ versus average log$_{2}$ ion counts of the heavy and light peak}
\end{figure}

<<chargeOxPlot>>=
barplot_theme <- theme(text = element_text(size = 20, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_blank(), legend.position = "none", panel.grid.minor = element_blank(), panel.grid.major.y = element_blank(), axis.ticks.x = element_blank(), axis.line = element_line()) 

combined_charge_ox_plot <- ggplot(combined_charge_ox, aes(x = correlation, fill = 'chartreuse3')) + facet_grid(~ comparison) + barplot_theme
combined_charge_ox_plot + geom_bar() + scale_x_continuous(name = "Pearson Correlation", expand = c(0.01,0.01), limits = c(-1,1)) + scale_y_continuous(name = "Counts", expand = c(0.01, 0.01)) + scale_fill_identity()
@




<<>>=

nbins <- 50
var_spline_inst <- list()
var_spline_plot <- list()

for(inst in unique(bioRepPlot$Instrument)){
  # calculate a variance/precision kernal over instrument*IC
  instSubset <- bioRepPlot[bioRepPlot$Instrument == inst,]
  binsize <- floor(length(instSubset[,1])/nbins)
  error_bins <- data.frame(val_mean = instSubset$averageIC[order(instSubset$SN)], light_val = instSubset$experimental[order(instSubset$SN)], SN = instSubset$SN[order(instSubset$SN)], bin = c(rep(1:(length(instSubset[,1]) %% nbins), each = binsize + 1), rep(((length(instSubset[,1]) %% nbins) + 1):nbins, each = binsize)))

  bin_var <- data.frame(logIC = rep(NA, times = nbins), SN = NA, MLE_var = NA)
  bin_dist_plot <- NULL

  for(bin in 1:nbins){
    bin_var$logIC[bin] <- mean(error_bins[error_bins$bin == bin,]$val_mean)
    bin_var$SN[bin] <- mean(error_bins[error_bins$bin == bin,]$SN)
      
	  #calculate unbiased estimate of variance
	  resid_dist <- (error_bins[error_bins$bin == bin,]$light_val - error_bins[error_bins$bin == bin,]$val_mean)*sqrt(2)
    #get the average residual magnitude and then square for the varianace
	  bin_var$MLE_var[bin] <- mean(abs(resid_dist[abs(resid_dist) < sd(resid_dist)*3]))^2
	
	}
  var_spline <- smooth.spline(x = log10(bin_var$SN), y = bin_var$MLE_var, df = 11)
  var_spline_inst[[inst]] <- var_spline
  var_spline_plot$spline <- rbind(var_spline_plot$spline, data.frame(predict(var_spline, log10(seq(min(bin_var$SN), max(bin_var$SN), diff(c(min(bin_var$SN), max(bin_var$SN)))/(nbins*10)))), instrument = inst))
  var_spline_plot$bins <- rbind(var_spline_plot$bins, data.frame(bin_var, instrument = inst))
    
}

@

<<>>=
SNvsIC <- data.frame(melt((log2(lightIC) + log2(heavyIC))/2),melt(peptideSN)[,3])
colnames(SNvsIC) <- c("peptide", "condition", "meanIC", "SN")
SNvsIC <- SNvsIC[apply(data.frame(is.finite(SNvsIC[,3]), is.finite(SNvsIC[,4])), 1, sum) == 2,]

hex_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "aliceblue"), legend.position = "top", strip.background = element_rect(fill = "cornflowerblue"), strip.text = element_text(color = "cornsilk"), panel.grid.minor = element_blank(), panel.grid.major = element_blank(), axis.line = element_blank(), legend.key.width = unit(6, "line")) 

LHscatter <- ggplot(SNvsIC, aes(y = SN, x = meanIC)) + hex_theme + scale_x_continuous("meanIC", expand = c(0.02,0.02)) + scale_y_continuous("SN", expand = c(0.01,0.01)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7))
LHscatter + geom_hex(bins = 200)

LHscatter <- ggplot(SNvsIC[SNvsIC$SN > 2^-5,] , aes(y = log2(SN), x = meanIC)) + hex_theme + scale_fill_gradientn(name = "Counts", colours = rainbow(7))
LHscatter + geom_hex(bins = 200)


@



\begin{figure}
<<pooled_var_plot, echo = FALSE, cache = TRUE, fig.width=10, fig.height=6>>=
scatter_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "azure"), legend.position = "none", panel.grid.minor = element_blank(), panel.grid.major = element_line(colour = "pink"), axis.ticks = element_line(colour = "pink"), strip.background = element_rect(fill = "cyan")) 


ggplot() + facet_grid(~ instrument) + geom_line(data = var_spline_plot$spline, aes(x = x, y = y, color = "RED", size = 2)) + scatter_theme + scale_x_continuous("Log average H/L IC") + scale_y_continuous("average pooled standard deviation") + scale_color_identity() + scale_size_identity() + geom_point(data = var_spline_plot$bins, aes(x = log10(SN), y = MLE_var, color = "blue", size = 3))

ggplot() + facet_grid(~ instrument) + geom_line(data = var_spline_plot$spline, aes(x = x, y = y, color = "RED", size = 2)) + scatter_theme + scale_x_continuous("Log average H/L IC") + scale_y_continuous("average pooled standard deviation", limits = c(0,1)) + scale_color_identity() + scale_size_identity() + geom_point(data = var_spline_plot$bins, aes(x = log10(SN), y = MLE_var, color = "blue", size = 3))

@
\caption{pooling peptides by mean($log_{2}^{H}, log_{2}^{L}$) and within these pools looking at the average variance}
\label{poole_var_fig}
\end{figure}

Estimating the variance of light/heavy biological/technical replicates based upon the signal:noise of the heavy and light peptides measurement







From the results above, the variance of peptide abundances is clearly a decreasing function of peak size.  In order to form a more robust estimate of variance as a function of ion-count, peptides were sorted by mean($log_{2}X^{H}, log_{2}X^{L}$) and pooled into \Sexpr{nbins} binds,  containing \Sexpr{binsize}-\Sexpr{binsize+1} peptides.  The variance within these bins was calculated as according to equation \ref{poolvar}, and a 5$^{th}$ degree spline was fit through these points (figure \ref{poole_var_fig}).  This estimate of V(IC) can be used as a prediction of how close a peptides relative abundance is to the population parameter of interest, the protein mean. 

\begin{align}
\epsilon_{p} &= X_{p}^{H} - X_{p}^{L}\notag\\
\sigma^{2} &= mean(|\epsilon_{p} * \sqrt{2}|)^{2}\label{poolvar}
\end{align}

\normalsize

\begin{figure}[h!]
<<nshare, dependson = "dataImp", echo = FALSE>>=
barplot(nsharedpep, col = "burlywood2")
@
\caption{Number of proteins that a measured peptide matches}
\end{figure}

In order to determine the expected variance of the relative abundance of a peptide($\mathbf{X}_{ic}$ about the relative abundance of its corresponding protein ($\mathbf{\Omega}_{kc}$), we assume that $\mathbf{X}_{ic} \sim N(\mathbf{\Omega}_{kc}, \sigma^{2}_{ic}$) with $E[\sigma^{2}_{ic}]$ being fitted either from residuals or replicates.

Fitting from replicates can be done because all of the samples are quantified with respect to a common reference p0.05, including an experimental sample of p0.05.  The difference between these  



\clearpage
\normalsize

\subsection*{Normalization to account for differences in protein concentrations across conditions}

Determining the intracellular concentration of proteins, the desired normalization measurement required integrating data from several other documents.  Briefly the method involved.

\begin{itemize}
\item For each condition (25 experimental and 2 reference chemostats), 80-400mL was collected on ice and spun down to gather a large pellet of cells.
\item The dry weight of each sample was determined after 36 hours of lyophilization on a speed-vacuum at \textcolor{red}{50$^{o}$C - check}.
\item The sample was resuspended in 900$\mu$L KH$_{2}$PO$_{4}$-EDTA with 0.5\% Triton-X-100, split into 3 replicates and 20$\mu$L of each sub-sample was aliquoted into 12 96-well plates.
\item For the protein assay, 10$\mu$L of one such plate was diluted in 190$\mu$L of the $\mu$L KH$_{2}$PO$_{4}$-EDTA-Triton-X buffer and 9$\mu$L of this diluted sample was quantified using the Thermo BCA protein assay kit. 
\item For cellular volume per mL of media, a Coulter counter was used to count the number and volume of cells in a dilution of media.  The product of the mean cellular volume, number of cells and dilution factor gives the correct quantity.
\item Fraction of protein was calculated by correcting for dilution and splitting and then compared to dry weight.  The concentration of proteins per cell was found by determining the concentration of proteins per mL of media and dividing by the cellular volume per mL of media
\end{itemize}

To correct for differences in protein concentrations between samples, the relative abundances were corrected by adding a factor $\Delta_{j}$, as per equation \ref{normalizeC}.
\begin{align}
\text{Initial loading disparity}&\notag\\
\delta^{o}_{j} &= log_{2}(\text{med}[\frac{P^{L}_{j}}{P^{H}_{j}}])\notag\\
%\text{Desired concentration offset}&\notag\\
%\delta_{j} &= log_{2}([protein^{L}_{j}] - [protein^{H}_{j}])\notag\\
%\Delta_{j} &= \delta_{j}  - \delta^{o}_{j}\notag\\
%X^{*}_{ij} &= X_{ij} + \Delta_{j}\label{normalizeC}
X^{*}_{ij} &= X_{ij} - \delta^{o}_{j}\label{normalizeC}
\end{align}




<<normalizeProtAbund, dependson = "EMprep", cache = TRUE>>=
load('../BulkComposition/protSpecQuantOut.Rdata')

sampleChemoInfo <- conditions[sapply(proteomicsBlocking$Condition, function(x){c(1:length(conditions[,1]))[conditions$condition == x]}),] #align chemostat conditions to tech replicates

added_conds <- conditions[conditions$condition == "p0.30",]; added_conds$condition <- "p0.30_ORBI"
conditions <- rbind(conditions, added_conds)

cond_info <- sapply(colnames(good_light), function(cond){
	if(strsplit(cond, "")[[1]][1] == "L"){
		tmp <- cond
		}else{
			tmp <- paste(c(tolower(strsplit(cond, "")[[1]][1]), strsplit(cond, "")[[1]][-1]), collapse = "")
			}
		c(1:length(conditions[,1]))[conditions$condition == tmp]
		})

conditions <- conditions[cond_info,]

initial_offset = log2(apply(good_light/good_heavy, 2, median, na.rm = TRUE))

abundMat <- abundMat + rep(1, times = length(abundMat[,1])) %*% t(-1*initial_offset)

@

\begin{figure}[h!]
<<prot_cellular_conc, echo = FALSE, cache = TRUE>>=
pconc_plot <- ggplot(plotting_DF, aes(x = factor(Condition), y = Concentration, col = limitation)) + facet_wrap(~ Iteration, ncol = 1) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("mg protein/uL cellular volume") + scale_x_discrete("Experimental condition")
pconc_plot + geom_boxplot() 
@
\caption{Concentration of proteins (mg) per $\mu$L cellular volume.  The top panel contains the raw transformed protein concentrations.  It is notable that some treatments are measured poorly, with a great discordance between technical replicates.  There is a strong linear trend across dilution rates within each limitation, so this could serve as a fitted value for each condition.  To minimize the influence of outliers, we want to find a point estimate of the concentration of protein in each condition that balances the actual possibly noisy value measured, with the predicted value from the structure of the data.  The balance of using the experimental measurement or the fitted value is determined by how noisy the experimental measurement is relative to the residual mean square error of the regression fit.}
\label{prot_cellular_conc}
\end{figure}

\begin{figure}[h!]
<<prot_frac_DW, echo = FALSE, cache = TRUE>>=
dw_plot <- ggplot(dry_weight_DF, aes(x = factor(condition), y = ProteinDW_fraction, col = limitation)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Protein fraction of dry-material") + scale_x_discrete("Experimental condition")
dw_plot + geom_boxplot()
@
\caption{Fraction of dry weight taken up by proteins}
\label{prot_frac_DW}
\end{figure}

\begin{figure}[h!]
<<dry_weight_dens, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot1 <- ggplot(dry_weight_turnover_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight(mg) per mL culture", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot1 + geom_bar(stat = "identity", position = "stack")
@
\caption{Dry weight (mg) per mL of culture: Maximal density is seen at low growth rates except under carbon and leucine limitation}
\label{dry_weight_dens}
\end{figure}

\begin{figure}[h!]
<<dry_weight_turnover, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot2 <- ggplot(dry_weight_turnover_DFmelt2, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight production (mg/hr) per mL culture", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot2 + geom_bar(stat = "identity", position = "stack")
@
\caption{Dry weight per mL * DR (h$^{-1}$ indicates that optimal growth, in terms of biomass production occurs at intermediate GRs}
\label{dry_weight_turnover}
\end{figure}

\begin{figure}[h!]
<<dry_weight_cellconc, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_turnover_plot3 <- ggplot(dry_weight_turnover_D_cellular_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold")) + scale_y_continuous("Dry weight (mg) per uL of cellular volume", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_turnover_plot3 + geom_bar(stat = "identity", position = "stack")
@
\caption{Concentration of proteins and dry-matter per cellular volume (mg/uL).  The protein relative concentrations are equivalent to the means of the figure \ref{prot_cellular_conc} box plot}
\label{dry_weight_cellconc}
\end{figure}

\begin{figure}[h!]
<<material_percell, echo = FALSE, cache = TRUE, warning = FALSE>>=
dry_weight_perCell_plot <- ggplot(dry_weight_perCell_DFmelt, aes(x = factor(Condition), y = value, fill = variable)) + theme(axis.text.x = element_text(size = 4, face = "bold"), panel.grid.minor=element_blank(), panel.grid.major=element_blank()) + scale_y_continuous("pg protein/dry-material per cell", expand = c(0,0)) + scale_x_discrete("Experimental condition") + scale_fill_brewer(palette = "Set1")
dry_weight_perCell_plot + geom_bar(stat = "identity", position = "stack")
@
\caption{pico-grams protein per cell: The smaller size of nitrogen and carbon limited cells results in them having less material per-cell.  For most conditions, at slow growth-rates cells either become minute or huge and then tend back towards a similar intermediate size as growth-rates increase.  This makes carbon and C, N and L look more similar in terms of total material per cell, while uracil looks radically different}
\label{material_percell}
\end{figure}





\small

<<EMsetup, dependson = "dataImp", cache = TRUE>>=

#save(abundMat, good_heavy, good_light, var_spline_inst, file = "tmp.Rdata")

library(reshape2)
library(nlme)

n_e <- length(proteomicsBlocking[,1])
conditions <- unique(proteomicsBlocking$Condition)
n_c <- length(conditions)
n_p <- sum(good_samples)
n_prot <- length(mappingMat[1,])  

euclidean_threshold <- 5

average_log2_ic <- (log2(good_light) + log2(good_heavy))/2
fitted_var_byIC <- good_light; fitted_var_byIC[!is.na(fitted_var_byIC)] <- NA
  
for(j in 1:length(fitted_var_byIC[1,])){
  fitted_var_byIC[!is.na(average_log2_ic[,j]),j] <- predict(var_spline_inst[[proteomicsBlocking$Instrument[j]]], x = average_log2_ic[,j][!is.na(average_log2_ic[,j])])$y
  }


###########

inst_set_level_joined <- apply(proteomicsBlocking, 1, function(x){
    paste(x[names(x) %in% c("Instrument", "Set")], collapse = "_")
    })

inst_block_level_joined <- apply(proteomicsBlocking, 1, function(x){
    paste(x[names(x) %in% c("Instrument", "Set", "Block")], collapse = "_")
    })

### fit relative abundance with condition and blocking main effects to generate LS fit ###
filtered_peps <- abundMat; filtered_peps[is.na(filtered_peps) | !is.na(filtered_peps)] <- 0
outlier_type <- filtered_peps; outlier_type[!is.na(outlier_type)] <- NA

for(a_pep_n in 1:n_p){
  
  peptide_model <- data.frame(RA = abundMat[a_pep_n,], proteomicsBlocking, totalBlocking = inst_block_level_joined, setBlocking = inst_set_level_joined, is_outlier = FALSE, outlier_type = NA)
  peptide_model <- peptide_model[!is.na(peptide_model$RA),]
  
  #plot(peptide_model$RA, col = factor(peptide_model$setBlocking), pch = peptide_model$Block)
  
  peptide_model$index <- 1:length(peptide_model[,1])
  
  ### Prune individual points if they are strong outliers based upon a bonferroni-corrected wald test
  wald_p <- 1 - abs(pnorm((peptide_model$RA - mean(peptide_model$RA))/sd(peptide_model$RA)) - 0.5)*2
  peptide_model$is_outlier[wald_p < 0.05/length(wald_p) & abs(peptide_model$RA) > 5] <- TRUE
  peptide_model$outlier_type[wald_p < 0.05/length(wald_p) & abs(peptide_model$RA) > 5] <- "point"
  
  ### if a peptide is broadly consistent then rather than doing aggresive pruning, the peptides added variance will be accounted for at the level of expected precision
  
  block_prune <- TRUE
  RA_blocks <- acast(peptide_model[!peptide_model$is_outlier,], Condition ~  Instrument + Set + Block, value.var = "RA")
  index_blocks <- acast(peptide_model[!peptide_model$is_outlier,], Condition ~  Instrument + Set + Block, value.var = "index")
  mean_euclid_dist <- data.frame(average_euclid_d = rep(NA, length(RA_blocks[1,])), mean_val = NA, index = 1:length(RA_blocks[1,]))
  isolated_indeces <- NULL
  totally_inconsistent <- FALSE #if all condition pairs are inconsistent then the peptide will be discarded
  
  for(j in c(1:length(mean_euclid_dist[,1]))){
      primary_set <- RA_blocks[!is.na(RA_blocks[,j]),j]
      if(length(primary_set) == 1 | length(RA_blocks[1,]) == 2){next}
      
      compare_set <- apply(RA_blocks[!is.na(RA_blocks[,j]),-j], 1, mean, na.rm = TRUE)
      if(sum(!is.nan(compare_set)) == 0){next}
      
      mean_euclid_dist[j,1:2] <- c(mean((primary_set[!is.nan(compare_set)] - compare_set[!is.nan(compare_set)])^2), mean(primary_set))
      } # measure the euclidean distance between technical replicates in different blocks
  
  if(sum(mean_euclid_dist[!is.na(mean_euclid_dist[,1]),1] > euclidean_threshold) > length(mean_euclid_dist[,1][!is.na(mean_euclid_dist[,1])])/2){
    filtered_peps[a_pep_n, !is.na(abundMat[a_pep_n,])] <- peptide_model$is_outlier
    peptide_model$outlier_type[is.na(peptide_model$outlier_type)] <- "peptide"
    outlier_type[a_pep_n, !is.na(abundMat[a_pep_n,])] <- peptide_model$outlier_type
    next # peptides with a high variance are noted and skipped - this inflated variance will be accounted for by inflating variance / decreasing precision
    }
  
  ### Prune blocks if they are highly inconsistent with the average of other replicates (more extreme and high variance) ###
  ### check to see whether there are blocks of data which are poor and if so flag them in the "outlier_type" and "filtered_peps" array ###
  
  if(length(unique(peptide_model$setBlocking)) != 1){
  
  while(block_prune == TRUE){
    
    for(j in c(1:length(mean_euclid_dist[,1]))){
      primary_set <- RA_blocks[!is.na(RA_blocks[,j]),j]
      if(length(primary_set) == 1 | length(RA_blocks[1,]) == 2){next}
      
      compare_set <- apply(RA_blocks[!is.na(RA_blocks[,j]),-j], 1, mean, na.rm = TRUE)
      if(sum(!is.nan(compare_set)) == 0){next}
      
      mean_euclid_dist[j,1:2] <- c(mean((primary_set[!is.nan(compare_set)] - compare_set[!is.nan(compare_set)])^2), mean(primary_set))
      }
    
    
    isolated_indeces <- c(isolated_indeces, mean_euclid_dist$index[is.na(mean_euclid_dist$average_euclid_d)])
    RA_blocks <- RA_blocks[,!is.na(mean_euclid_dist$average_euclid_d)]
    mean_euclid_dist <- mean_euclid_dist[!is.na(mean_euclid_dist$average_euclid_d),]
    
    if(length(mean_euclid_dist[,1]) >= 2){
    
      if(max(mean_euclid_dist$average_euclid_d) > euclidean_threshold){
        #Remove one block with high euclidean distance and extreme mean value
        index_reorder <- mean_euclid_dist[order(mean_euclid_dist$average_euclid_d, decreasing = TRUE),]
        index_reorder <- index_reorder[index_reorder$average_euclid_d > euclidean_threshold & index_reorder$average_euclid_d > max(index_reorder$average_euclid_d)/2,]
        RA_blocks <- RA_blocks[,!(mean_euclid_dist$index == index_reorder$index[which.max(abs(index_reorder$mean_val))])]
        mean_euclid_dist <- mean_euclid_dist[!(mean_euclid_dist$index == index_reorder$index[which.max(abs(index_reorder$mean_val))]),]
        }else{
          block_prune = FALSE
          }
        }
    
     if(length(mean_euclid_dist[,1]) <= 2){
      totally_inconsistent <- TRUE
      block_prune <- FALSE
      }
  
    }
   
  bad_block_samples <- index_blocks[,!(c(1:length(index_blocks[1,])) %in% mean_euclid_dist$index)]
  bad_block_samples <- bad_block_samples[!is.na(bad_block_samples)] #list samples in blocks that were removed due to inconsistency or being disjoint
  
  disjoint_samples <- unlist(index_blocks[,isolated_indeces])[!is.na(unlist(index_blocks[,isolated_indeces]))]
  bad_block_samples <- bad_block_samples[!(bad_block_samples %in% disjoint_samples)] #reduce this list to only samples which were inconsistent
  
  peptide_model$is_outlier[bad_block_samples] <- TRUE
  peptide_model$outlier_type[bad_block_samples] <- "block"
  
  if(totally_inconsistent){
    totally_inconsistent <- FALSE; peptide_model$outlier_type[is.na(peptide_model$outlier_type)] <- "sparse"}
  }
  
  #plot(peptide_model$RA ~ factor(peptide_model$Condition), col = factor(peptide_model$totalBlocking))
  
  filtered_peps[a_pep_n, !is.na(abundMat[a_pep_n,])] <- peptide_model$is_outlier
  peptide_model$outlier_type[is.na(peptide_model$outlier_type)] <- "valid"
  outlier_type[a_pep_n, !is.na(abundMat[a_pep_n,])] <- peptide_model$outlier_type
}


@

<<pooled_variance, dependson = "dataImp", cache = TRUE>>=

refSamples <- proteomicsBlocking[proteomicsBlocking$Condition == "p0.05",]
# generate an instrument-specific function
bioRepPlot <- NULL


for(inst in unique(refSamples$Instrument)){
  logLight = data.frame(log2(good_light[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]]))
  logHeavy = data.frame(log2(good_heavy[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]]))
  outlier_type_ref <- data.frame(outlier_type[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]])
  pepSN = data.frame(good_SN[,proteomicsBlocking$SampleName %in% refSamples$SampleName[refSamples$Instrument == inst]])
  
  avgSignalSTD <- data.frame((logLight + logHeavy)/2)
  
  for(a_sample in 1:length(refSamples$SampleName[refSamples$Instrument == inst])){
    outlier_type_redvec = outlier_type_ref[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    logLight_redvec = logLight[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    logHeavy_redvec = logHeavy[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    avgSignal_redvec = avgSignalSTD[is.finite(avgSignalSTD[,a_sample]),a_sample]
    logLight_redvec <- logLight_redvec + optimize(normFactor, c(-1, 1), logLight = logLight_redvec[outlier_type_redvec == "valid"], logHeavy = logHeavy_redvec[outlier_type_redvec == "valid"])$minimum
    SN_redvec <- pepSN[,a_sample][is.finite(avgSignalSTD[,a_sample])]
    
    bioRepPlot <- rbind(bioRepPlot, data.frame(experimental = logLight_redvec, reference = logHeavy_redvec, averageIC = avgSignal_redvec, variance = (logLight_redvec - avgSignal_redvec)^2*2,Instrument = inst, Set = refSamples$Set[refSamples$Instrument == inst][a_sample], SN = SN_redvec, outlier_type = outlier_type_redvec))
    
    }
  }

hex_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "aliceblue"), legend.position = "top", strip.background = element_rect(fill = "cornflowerblue"), strip.text = element_text(color = "cornsilk"), panel.grid.minor = element_blank(), panel.grid.major = element_blank(), axis.line = element_blank(), legend.key.width = unit(6, "line")) 

LHscatter <- ggplot(bioRepPlot, aes(y = experimental, x = reference)) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("log2 N-15 labelled p0.05", expand = c(0.02,0.02)) + scale_y_continuous("log2 Unlabelled p0.05", expand = c(0.01,0.01)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7))
LHscatter + geom_hex(bins = 200) + ggtitle("p0.05H ~ p0.05L")

LHscatter <- ggplot(bioRepPlot[bioRepPlot$outlier_type == "valid",], aes(y = experimental, x = reference)) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("log2 N-15 labelled p0.05", expand = c(0.02,0.02)) + scale_y_continuous("log2 Unlabelled p0.05", expand = c(0.01,0.01)) + scale_fill_gradientn(name = "Counts", colours = rainbow(7))
LHscatter + geom_hex(bins = 200) + ggtitle("p0.05H ~ p0.05L Filtered")

LHscatter <- ggplot(bioRepPlot[bioRepPlot$outlier_type != "valid",], aes(y = experimental, x = reference, col = outlier_type)) + facet_grid(~ Instrument + Set, scales = "free") + hex_theme + scale_x_continuous("log2 N-15 labelled p0.05", expand = c(0.02,0.02)) + scale_y_continuous("log2 Unlabelled p0.05", expand = c(0.01,0.01)) + scale_color_brewer(palette = "Set2") 
LHscatter + geom_point(size = 1.5) + geom_abline(intercept = 0, slope = 1, size = 2) + ggtitle("p0.05H ~ p0.05L Outliers")


##### Fitting Var(IC) #####


nbins <- 50
var_spline_inst <- list()
var_spline_plot <- list()

for(inst in unique(bioRepPlot$Instrument)){
  # calculate a variance/precision kernal over instrument*IC
  instSubset <- bioRepPlot[bioRepPlot$Instrument == inst & !(bioRepPlot$outlier_type %in% c("block", "point")),]
  binsize <- floor(length(instSubset[,1])/nbins)
  error_bins <- data.frame(val_mean = instSubset$averageIC[order(instSubset$averageIC)], light_val = instSubset$experimental[order(instSubset$averageIC)], bin = c(rep(1:(length(instSubset[,1]) %% nbins), each = binsize + 1), rep(((length(instSubset[,1]) %% nbins) + 1):nbins, each = binsize)))

  bin_var <- data.frame(logIC = rep(NA, times = nbins), MLE_var = rep(NA, times = nbins))
bin_dist_plot <- NULL

  for(bin in 1:nbins){
    bin_var$logIC[bin] <- mean(error_bins[error_bins$bin == bin,]$val_mean)
  
	  #calculate unbiased estimate of variance
	  resid_dist <- (error_bins[error_bins$bin == bin,]$light_val - error_bins[error_bins$bin == bin,]$val_mean)*sqrt(2)
	  #get the average residual magnitude and then square for the varianace
	  bin_var$MLE_var[bin] <- mean(abs(resid_dist[abs(resid_dist) < sd(resid_dist)*3]))^2
	
	}
  var_spline <- smooth.spline(x = bin_var$logIC, y = bin_var$MLE_var, df = 4)
  var_spline_inst[[inst]] <- var_spline
  var_spline_plot$spline <- rbind(var_spline_plot$spline, data.frame(predict(var_spline, seq(min(bin_var$logIC), max(bin_var$logIC), diff(c(min(bin_var$logIC), max(bin_var$logIC)))/(nbins*10))), instrument = inst))
  var_spline_plot$bins <- rbind(var_spline_plot$bins, data.frame(bin_var, instrument = inst))
    
}

ggplot() + facet_grid(~ instrument) + geom_line(data = var_spline_plot$spline, aes(x = x, y = y, color = "RED", size = 2)) + scatter_theme + scale_x_continuous("Log average H/L IC") + scale_y_continuous("average pooled standard deviation") + scale_color_identity() + scale_size_identity() + geom_point(data = var_spline_plot$bins, aes(x = logIC, y = MLE_var, color = "blue", size = 3))

##### Fitting Var(SN) #######

nbins <- 50
var_spline_inst <- list()
var_spline_plot <- list()

for(inst in unique(bioRepPlot$Instrument)){
  # calculate a variance/precision kernal over instrument*IC
  instSubset <- bioRepPlot[bioRepPlot$Instrument == inst & !(bioRepPlot$outlier_type %in% c("block", "point")),]
  binsize <- floor(length(instSubset[,1])/nbins)
  error_bins <- data.frame(val_mean = instSubset$averageIC[order(instSubset$SN)], light_val = instSubset$experimental[order(instSubset$SN)], SN = instSubset$SN[order(instSubset$SN)], bin = c(rep(1:(length(instSubset[,1]) %% nbins), each = binsize + 1), rep(((length(instSubset[,1]) %% nbins) + 1):nbins, each = binsize)))

  bin_var <- data.frame(logIC = rep(NA, times = nbins), SN = NA, MLE_var = NA)
  bin_dist_plot <- NULL

  for(bin in 1:nbins){
    bin_var$logIC[bin] <- mean(error_bins[error_bins$bin == bin,]$val_mean)
    bin_var$SN[bin] <- mean(error_bins[error_bins$bin == bin,]$SN)
      
    #calculate unbiased estimate of variance
	  resid_dist <- (error_bins[error_bins$bin == bin,]$light_val - error_bins[error_bins$bin == bin,]$val_mean)*sqrt(2)
    #get the average residual magnitude and then square for the varianace
	  bin_var$MLE_var[bin] <- mean(abs(resid_dist[abs(resid_dist) < sd(resid_dist)*3]))^2
	
	}
  var_spline <- smooth.spline(x = log10(bin_var$SN), y = bin_var$MLE_var, df = 11)
  var_spline_inst[[inst]] <- var_spline
  var_spline_plot$spline <- rbind(var_spline_plot$spline, data.frame(predict(var_spline, log10(seq(min(bin_var$SN), max(bin_var$SN), diff(c(min(bin_var$SN), max(bin_var$SN)))/(nbins*10)))), instrument = inst))
  var_spline_plot$bins <- rbind(var_spline_plot$bins, data.frame(bin_var, instrument = inst))
    
}

scatter_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "azure"), legend.position = "none", panel.grid.minor = element_blank(), panel.grid.major = element_line(colour = "pink"), axis.ticks = element_line(colour = "pink"), strip.background = element_rect(fill = "cyan")) 


ggplot() + facet_grid(~ instrument) + geom_line(data = var_spline_plot$spline, aes(x = x, y = y, color = "RED", size = 2)) + scatter_theme + scale_x_continuous("Log average H/L IC") + scale_y_continuous("average pooled standard deviation") + scale_color_identity() + scale_size_identity() + geom_point(data = var_spline_plot$bins, aes(x = log10(SN), y = MLE_var, color = "blue", size = 3))

ggplot() + facet_grid(~ instrument) + geom_line(data = var_spline_plot$spline, aes(x = x, y = y, color = "RED", size = 2)) + scatter_theme + scale_x_continuous("Log average H/L IC") + scale_y_continuous("average pooled standard deviation", limits = c(0,1)) + scale_color_identity() + scale_size_identity() + geom_point(data = var_spline_plot$bins, aes(x = log10(SN), y = MLE_var, color = "blue", size = 3))

bioRepPlot_outlier <- bioRepPlot
bioRepPlot_outlier$outlier_type[is.na(bioRepPlot_outlier$outlier_type)] <- "valid"
bioRepPlot_outlier_plot <- ggplot(data = bioRepPlot_outlier, aes(x = SN, fill = outlier_type)) + facet_wrap(~ outlier_type, scales = "free_y")
bioRepPlot_outlier_plot + geom_bar(binwidth = 5) + scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0))
@




<<>>=

library(data.table)
library(ggplot2)

save(list = ls(), file = "tmp.Rdata")
load("tmp.Rdata")

# remove outliers
# fit SD(IC) or SD(SN)
# fit a mixed-effect linear model with weights of SD(IC) to determine point estimates abundance
# determine the extent of over-dispersion (plot across proteins)

point_estimates <- matrix(NA, ncol = n_c, nrow = n_p); rownames(point_estimates) <- rownames(abundMat); colnames(point_estimates) <- unique(proteomicsBlocking$Condition)
precision_estimates <- point_estimates
dispersion_adj <- rep(NA, n_p)
dispersion_SW_test <- rep(NA, n_p)


for(a_pep_n in 1:n_p){
  
  peptide_model <- data.table(RA = abundMat[a_pep_n,], proteomicsBlocking, totalBlocking = inst_block_level_joined, setBlocking = inst_set_level_joined, lightIC = log2(good_light[a_pep_n,]), heavyIC = log2(good_heavy[a_pep_n,]), averageIC = (log2(good_light[a_pep_n,]) + log2(good_heavy[a_pep_n,]))/2, SN = good_SN[a_pep_n,], outlier_type = outlier_type[a_pep_n,], index = 1:n_e)
  peptide_model <- peptide_model[!is.na(peptide_model$RA),]
  peptide_model <- peptide_model[!(peptide_model$outlier_type %in% c("point", "block")),]
  
  if(nrow(peptide_model) < n_e*quality_frac){next}
  
  peptide_model[, var_fit:=predict(var_spline_inst[[Instrument]], log10(SN))$y, by=index]
  peptide_model <- peptide_model[is.finite(peptide_model$var_fit),] #remove infinite variance because not informative
  
  ### fitting condition-specific peptide abundance ###
  
  peptide_model[, fitted:=weighted.mean(RA, 1/var_fit), by=Condition]
  
  if(sum(table(peptide_model$Condition) >= 2) < 5 & all(peptide_model$outlier_type == "peptide")){next}
  
  ### Determine the extent of peptide-level overdispersion ###
  if(sum(table(peptide_model$Condition) >= 2) >= 5){
    repeated_conds <- peptide_model
    repeated_conds[, nreps:=length(fitted), by=Condition]
    repeated_conds <- repeated_conds[repeated_conds[,nreps >= 2],]
    
    dispersion_adj[a_pep_n] <- mean(repeated_conds[, (RA - fitted)^2 * nreps/(nreps - 1) * (1/var_fit),])
    dispersion_SW_test[a_pep_n] <- shapiro.test(repeated_conds[, (RA - fitted) * sqrt(nreps/(nreps - 1)) * 1/sqrt(var_fit*dispersion_adj[a_pep_n]) ,])$p
    
    CV_dispersions(repeated_conds, 5)
    
  
    
    
    
    } else{dispersion_adj[a_pep_n] <- 1}
    
  peptide_model$precision_adj <- 1/(peptide_model$var_fit*dispersion_adj[a_pep_n])
  
  cond_summary <- data.frame(condition = conditions, RA = NA, precision = NA)
  for(a_cond in 1:n_c){
    cond_summary[a_cond, 2:3] <- c(peptide_model$fitted[peptide_model$Condition == conditions[a_cond]][1], sum(peptide_model$precision_adj[peptide_model$Condition == conditions[a_cond]]))
    }
  
  point_estimates[a_pep_n,] <- cond_summary$RA
  precision_estimates[a_pep_n,] <- cond_summary$precision
  
}

hist(dispersion_SW_test, breaks = 50)

ggplot(data.frame(dispersion = dispersion_adj), aes(x = dispersion)) + geom_bar(binwidth = 0.01) + scale_x_continuous(limits = c(0,10))

ggplot(data.frame(dispersion = log2(dispersion_adj)), aes(x = dispersion)) + geom_bar(binwidth = 0.3, fill = "RED")
ggplot(data.frame(dispersion = log2(dispersion_adj), nvals = rowSums(!is.na(abundMat))), aes(y = dispersion, x = nvals)) + geom_jitter(size = 0.5)



dispersion_table <- data.table(pvalues = dispersion_SW_test, OD = dispersion_adj, nmeasurement = rowSums(!is.na(abundMat)))

fraction_plot <- data.table(min = (seq(0, 1, by = 0.2)*n_e)[1:5], max = (seq(0, 1, by = 0.2)*n_e)[2:6], min_label = seq(0, 100, by = 20)[1:5], max_label = seq(0, 100, by = 20)[2:6])
fraction_plot[,label:= paste(c(paste(c(min_label, max_label), collapse = "-"), "%"), collapse = ""),by = min]

dispersion_table[, sample_fraction:= fraction_plot$label[fraction_plot$max >= nmeasurement][1], by = nmeasurement]
ggplot(dispersion_table, aes(x = pvalues)) + facet_wrap(~ sample_fraction, ncol = 5) + geom_bar(binwidth = 0.05)
           
ggplot(dispersion_table[dispersion_table$OD != 1,], aes(x = factor(sample_fraction), y = log2(OD))) + geom_violin(scale = "count", fill = "darkgoldenrod1") + ggtitle("Overdispersion as fraction of missing values decreases")

dispersion_table[, median(log2(OD), na.rm = TRUE), by = sample_fraction]

### set the mean of OD to 0 and enforce a constant sd  ####

dispersion_adj_df <- data.table(dispersion = log2(dispersion_adj), nvals = rowSums(!is.na(abundMat)))
dispersion_adj_df <- dispersion_adj_df[dispersion != 0,]

mean_spline <- smooth.spline(dispersion_adj_df$dispersion ~ dispersion_adj_df$nvals, df = 3)
sd_spline <- smooth.spline(abs(dispersion_adj_df$dispersion) ~ dispersion_adj_df$nvals, df = 3)

plot(data = dispersion_adj_df, dispersion ~ jitter(nvals), pch = 16, cex = 0.5)
lines(predict(mean_spline, 1:n_e)$y ~ c(1:n_e), lwd = 3, col = "RED")

plot(data = dispersion_adj_df, abs(dispersion) ~ jitter(nvals), pch = 16, cex = 0.5)
lines(predict(sd_spline, 1:n_e)$y ~ c(1:n_e), lwd = 3, col = "RED")


######

fittedPrec <- precision_estimates
abundMat <- point_estimates

##### for each unique peptide, combine the multiple ionization states, methionine oxidation to produce a single point estimate, using integrated likelihood ####

### set the precision of missing values to 0; equivalent to no impact, infinite variance

fittedPrec[is.na(point_estimates)] <- 0
fittedPrec[is.na(fittedPrec)] <- 0
abundMat[fittedPrec == 0] <- 0

### averaging over ionization states
uniquePepMean <- as.matrix(((t(abundMat * fittedPrec)) %*% pepToUniq)/(t(fittedPrec) %*% pepToUniq))
uniquePepPrecision <- Matrix(t(fittedPrec) %*% pepToUniq)
uniquePepMean[is.nan(uniquePepMean)] <- 0

unique_mappingMat <- as.matrix(t(pepToUniq) %*% mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)

### averaging over methionine oxidation

uniquePepMean <- as.matrix(((uniquePepMean * uniquePepPrecision) %*% pepToUniqM)/uniquePepPrecision %*% pepToUniqM)
uniquePepPrecision <- uniquePepPrecision %*% pepToUniqM
uniquePepMean[is.nan(uniquePepMean)] <- 0

unique_mappingMat <- as.matrix(t(pepToUniqM) %*% unique_mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)

#number of non-missing values for peptides
Nmissing_val <- table(colSums(uniquePepMean != 0))

### remove peptides which have fewer than quality_frac representation

valid_peptides <- colSums(uniquePepMean != 0) >= quality_frac
  
uniquePepMean <- uniquePepMean[,valid_peptides]
uniquePepPrecision <- uniquePepPrecision[,valid_peptides]

unique_mappingMat <- unique_mappingMat[valid_peptides,]
unique_mappingMat <- unique_mappingMat[,colSums(unique_mappingMat) != 0]

#number of non-missing values for all peptides (before uniquenss combination)
Nmissing_val_all <- table(apply(is.finite(PepMatrix), 1, sum))

@

<<results = "asis", echo = FALSE>>=
print(xtable(data.frame(Proteins = n_prot, Peptides = n_p, Conditions = n_c), display = c("s", "d", "d", "d")), include.rownames = FALSE)
@


\begin{figure}[h!]
<<mvbarplot, dependson = "EMsetup", echo = FALSE>>=
barplot(Nmissing_val, col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val)) < ceiling(n_c * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val)) >= ceiling(n_c * quality_frac)))))

barplot(Nmissing_val_all, col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val_all)) < ceiling(n_e * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val_all)) >= ceiling(n_e * quality_frac)))))
@
\caption{Distribution of non-missing values for all peptides.  Peptides with non-missing values over the cutoff are shown in orange}
\label{nonmissingvals}
\end{figure}


<<mvmat, dependson = "EMsetup", cache = TRUE>>=

library(reshape2)

#look at structure in the missing values
binPepMatrixL <- lightIC; binPepMatrixL[binPepMatrixL < ICthreshold] <- NA; binPepMatrixL <- ifelse(is.finite(binPepMatrixL), 1, 0)
binPepMatrixH <- heavyIC; binPepMatrixH[binPepMatrixH < ICthreshold] <- NA; binPepMatrixH <- ifelse(is.finite(binPepMatrixH), 1, 0)
  
Overlap_lattice <- expand.grid(c(1:length(binPepMatrix[1,])), c(1:length(binPepMatrix[1,])))
colnames(Overlap_lattice) <- c("Row", "Column")
Overlap_lattice$Rowsample <- proteomicsBlocking$Condition[Overlap_lattice$Row]
Overlap_lattice$Colsample <- proteomicsBlocking$Condition[Overlap_lattice$Column]
Overlap_lattice$RowInstrument <- proteomicsBlocking$Instrument[Overlap_lattice$Row]
Overlap_lattice$ColInstrument <- proteomicsBlocking$Instrument[Overlap_lattice$Column]
Overlap_lattice$RowSet <- proteomicsBlocking$Set[Overlap_lattice$Row]
Overlap_lattice$ColSet <- proteomicsBlocking$Set[Overlap_lattice$Column]

OverlapSummary <- t(mapply(function(x,y){x + y
    counts <- table(binPepMatrix[,x], binPepMatrix[,y])
    c(counts[2,2]/(counts[2,1] + counts[1,2] + counts[2,2]), counts[2,2], counts[2,2]^2/((counts[2,1] + counts[2,2])*(counts[1,2] + counts[2,2])))
    }, Overlap_lattice[,1], Overlap_lattice[,2]))
colnames(OverlapSummary) <- c("IntersectVsUnion", "Intersection", "pMatchAB")

Overlap_lattice <- cbind(Overlap_lattice, OverlapSummary)
Overlap_lattice <- Overlap_lattice[Overlap_lattice$RowInstrument != "ORBI" & Overlap_lattice$ColInstrument != "ORBI",]

#IntersectVsUnion <- acast(Overlap_lattice, formula = Row ~ Column, mean, value.var = "IntersectVsUnion")
#Intersection <- acast(Overlap_lattice, formula = Row ~ Column, mean, value.var = "Intersection")
#pMatchAB <- acast(Overlap_lattice, formula = Row ~ Column, mean, value.var = "pMatchAB")

tile_theme <- theme(text = element_text(size = 18, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_blank(), legend.position = "top", panel.grid = element_blank(), legend.key.width = unit(6, "line"), axis.ticks = element_line(colour = "pink"), strip.background = element_rect(fill = "darkgray"), axis.text.x = element_text(angle = 90) ) 


IntersectVsUnion <- ggplot(Overlap_lattice, aes(Colsample, Rowsample, fill = IntersectVsUnion)) + facet_grid(RowInstrument + RowSet ~ ColInstrument + ColSet) + tile_theme
IntersectVsUnion + geom_tile() + scale_fill_gradient(limits = c(0,1), low="blue", high="yellow")

ggsave("figure/mvIntersectVsUnion.pdf", width = 15, height = 15)

set2block <- Overlap_lattice[Overlap_lattice$ColSet == 2 & Overlap_lattice$RowSet == 2,]
set2block$Rowsample <- as.factor(set2block$Rowsample); set2block$Colsample <- as.factor(set2block$Colsample)
levels(set2block$Rowsample) <- levels(set2block$Colsample) <- proteomicsBlocking[proteomicsBlocking$Set == 2,][order(proteomicsBlocking$Block[proteomicsBlocking$Set == 2], proteomicsBlocking$Order[proteomicsBlocking$Set == 2]),]$Condition
  
IntersectVsUnion <- ggplot(set2block, aes(Colsample, Rowsample, fill = IntersectVsUnion)) + tile_theme
IntersectVsUnion + geom_tile() + scale_fill_gradient(low="blue", high="yellow") + geom_vline(xintercept = 5.5 + 5*c(-1:4), size = 1.5) +  geom_hline(yintercept = 5.5 + 5*c(-1:4), size = 1.5)

ggsave("figure/mvIntersectVsUnionSet2.pdf", width = 8, height = 8)


IntersectVsUnion <- ggplot(Overlap_lattice, aes(Colsample, Rowsample, fill = Intersection)) + facet_grid(RowInstrument + RowSet ~ ColInstrument + ColSet) + tile_theme
IntersectVsUnion + geom_tile() + scale_fill_gradient(low="aliceblue", high="firebrick1")

ggsave("figure/mvIntersection.pdf", width = 15, height = 15)

###### Predict p(missing) as a function of treatment + instrument*block*set

#missingPeptideSource <- data.frame(Condition = rep(NA, times = length(binPepMatrixL[,1])), Condition_slope = NA, Instrument = NA, Set_Block = NA, Instrument_Set_Block = NA, HeavyPresent = NA)

#missingPeptideSource <- data.frame(residDF = rep(NA, times = length(binPepMatrixL[,1])), residDeviance = NA, modelDF = NA, modelDeviance = NA)
missingPeptideSource <- data.frame(fullAIC = rep(NA, times = length(binPepMatrixL[,1])), blockAIC = NA, minimalAIC = NA)

#sampleChemoInfo <- conditions[sapply(proteomicsBlocking$Condition, function(x){c(1:length(conditions[,1]))[conditions$condition == x]}),]

bio_offset <- model.matrix(~ factor(limitation)*actualDR + 0, sampleChemoInfo)
bio_slopes <- model.matrix(~ factor(limitation)*actualDR + 0, sampleChemoInfo)
blocking_variables <- model.matrix(~ factor(Instrument)*factor(Set)*factor(Block), proteomicsBlocking)
  
for(i in 1:length(missingPeptideSource[,1])){
  fullMod = glm(binPepMatrixL[i,] ~ binPepMatrixH[i,] + bio_variables + blocking_variables, family = binomial)
  blockMod = glm(binPepMatrixL[i,] ~ binPepMatrixH[i,] + blocking_variables, family = binomial)
  minimalMod = glm(binPepMatrixL[i,] ~ binPepMatrixH[i,], family = binomial)
  missingPeptideSource[i,] <- c(extractAIC(fullMod)[2], extractAIC(blockMod)[2], extractAIC(minimalMod)[2])
  
  ### permutation testing to determine if AIC values are as extreme as one would expect by chance - put this into another script if desired
  }
hist(missingPeptideSource[,2] - missingPeptideSource[,1], breaks = 200)
hist(missingPeptideSource[,3] - missingPeptideSource[,2], breaks = 200)

table(apply(missingPeptideSource, 1, which.min))
@


\begin{figure}[h!]
\begin{center}
\subfloat[p(A $\cap$ B)]{
\includegraphics[width=0.4\textwidth]{figure/mvIntersection.pdf}
}
\qquad
\subfloat[A $\cap$ B / A $\cup$ B)]{
\includegraphics[width=0.4\textwidth]{figure/mvIntersectVsUnion.pdf}}
\end{center}
\label{repFitSD2}
\caption{Overlap of missing ascertained peptides across conditions}
\end{figure}

\begin{figure}
<<missingPepbyCond, cache = TRUE>>=
#split by instrument facet with free_x
missingValByIC = data.frame(measuredPeptides = apply(!is.na(lightIC), 2, sum), TIC = apply(lightIC, 2, sum, na.rm = TRUE), limitation = sampleChemoInfo$limitation, instrument = proteomicsBlocking$Instrument, set = proteomicsBlocking$Set)

scatter_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "azure"), legend.position = "right", panel.grid.minor = element_blank(), panel.grid.major = element_line(colour = "pink"), axis.ticks = element_line(colour = "pink"), strip.background = element_rect(fill = "cyan")) 

missingValByICplot <- ggplot(missingValByIC, aes(x = measuredPeptides, y = TIC, color = factor(limitation), size = 3)) + facet_wrap(~ instrument + set, nrow = 1, scales = "free_y")
missingValByICplot + geom_point() + scatter_theme + scale_size_identity(NULL) + scale_color_discrete("Limitation")
@
\caption{Number of missing peptide values for an experiment versus limitation and TIC.  The point in the top-right is measured on an Orbi-trap.  Its large number of missing peptides, equivalent to the TOF suggests that the large number of missing peptides under phosphate limitation is due to blocking effects or biology rather than the Q-TOF not behaving appropriately during the first run}
\end{figure}


<<mvmat_red, dependson = "mvmat", cache = TRUE>>=
uq_ProtPepMatrix <- ProtPepMatrix[rowSums(ProtPepMatrix) == 1,]
uq_binPepMatrix <- cbind(binPepMatrixL, binPepMatrixH)[rowSums(ProtPepMatrix) == 1,]
  
  #binPepMatrix[rowSums(ProtPepMatrix) == 1,]

cond_peps <- t(((t(uq_binPepMatrix) %*% uq_ProtPepMatrix) != 0)*1)
cond_peps <- cond_peps[!(rowSums(cond_peps) %in% c(0, length(cond_peps[1,]))),]

@

\begin{figure}[h!]
<<misval_HM, dependson = "mvmat_red", echo = FALSE, warning = FALSE, cache = TRUE>>=
man_dist <- function(x){dist(x, method = "manhattan")}
heatmap.2(cond_peps, Rowv = TRUE, Colv = FALSE, trace = "none", col=blackOrange(100), distfun = man_dist, cexRow = 0.1)
@
\caption{hierarchical clustering of proteins missing in a subset of conditions using manhattan distance - a similarly clustered matrix for peptides is outputted but beyond R's clustering capabilities}
\end{figure}


<<cluster_misval, dependson = "mvmat_red", cache = TRUE>>=
	
k_clust_misVal <- 10

mv_clust <- stepFlexclust(cond_peps, k = k_clust_misVal, nrep=10, verbose=FALSE, FUN = kcca, family = kccaFamily(which = 'kmedians'))

clust_counts1 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)
clust_counts0 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)

for(kval in 1:k_clust_misVal){
	binsub <- cond_peps[mv_clust@cluster == kval,]
	clust_counts1[kval,] <- colSums(binsub)
	clust_counts0[kval,] <- length(binsub[,1]) - colSums(binsub)
	}
clust_ypos_adj <- matrix(5*rep(0:(k_clust_misVal-1), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_xpos <- matrix(rep(1:n_c, times = k_clust_misVal), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_num <- matrix(rep(1:(k_clust_misVal), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)

clust_plot_df <- data.frame(condition = c(c(clust_xpos), c(clust_xpos)), cluster_val = c(c(1 + clust_ypos_adj), c(clust_ypos_adj)),counts = c(c(clust_counts1), c(clust_counts0)), shape = as.factor(c(c(clust_num), c(clust_num))), medianoid = c(c(mv_clust@centers), c(1 - mv_clust@centers)))

clust_one_frac <- clust_counts1/(clust_counts1 + clust_counts0)
clusterCoherence <- apply(abs(clust_one_frac[,1:n_c] - clust_one_frac[,(n_c+1):length(clust_one_frac[1,])]), 1, mean)
clusterCoherenceDF <- data.frame(clusterCoherence, x = -3, y = clust_ypos_adj[,1] + 0.5)

@

\begin{figure}[h!]
<<plot_missingvalClusters, dependson = "cluster_misval", echo = FALSE, cache = TRUE>>=
manhattan_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "white"), legend.position = "right", panel.grid = element_blank(), axis.ticks = element_blank(), axis.text = element_blank())

clust_plot <- clust_plot + theme(axis.text.y = element_blank(), axis.title.y = element_blank()) + geom_vline(xintercept = n_c) + manhattan_theme
clust_plot + geom_point(data = clust_plot_df, aes(x = condition, y = cluster_val, size = counts, color = medianoid)) + 
  geom_point(data= clusterCoherenceDF, aes(x = x, y = y, color = clusterCoherence, size = 200)) + scale_color_gradient(low = "cornflowerblue",high = "RED")

@
\caption{Patterns of protein-level missing data over \Sexpr{n_c} experimental samples: experimental (light) on the left and reference (heavy) on the right.  Medianoids are indicated by the coloring of the dot in a cluster $\cdot$ condition,  sizes of the dots reflect how many proteins in that cluster are in agreement and disagreement with the medianoid in that condition.  Most large clusters reflect sparse missing or present data, while smaller clusters either reflect block/instrument associated missing data or some weak biological differences.  The dot to the left of each cluster reflects is the absolute value of the difference between p(1 | heavy) and p(1 | light), averaged over conditions.  This is measure of the discordance between L/H ascertainments.  GSEA could be performed on these clusters, but the only interesting clusters are too small to }
\end{figure}

<<dependson = "cluster_misval">>=

if(length(clusterCoherence[clusterCoherence > 0.2]) != 0){
  for(a_clust in c(1:k_clust_misVal)[clusterCoherence > 0.2]){
    clust_genes <- names(mv_clust@cluster)[mv_clust@cluster == a_clust]
    print(paste("Cluster", a_clust, "of", length(clust_genes), "genes"))
    gene_desc <- sapply(clust_genes, function(gene){try(orf2desc(unlist(strsplit(gene, split = '[/]'))[1]), silent = TRUE)})
    gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- sapply(names(gene_desc)[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})], function(gene){try(orf2desc(unlist(strsplit(gene, split = '[-/]'))[1]), silent = TRUE)})
    gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- "No Annotation"  
    print(unname(unlist(gene_desc)))
  }
}


@



names(mv_clust@cluster)[mv_clust@cluster == 1]




\clearpage
\normalsize
\section*{Going from peptides to proteins via expectation-maximization}

When using relative variation in peptides to predict variation in protein abundance we need to deal with two factors
\begin{itemize}
\item If a peptide maps to multiple proteins, it should be attributed to a protein (thereby adding signal) to the extent that its pattern matches the pattern from other peptides.
\item Some peptides won't conform to the trends of their protein because they may be the non-covalently modified complement of a set of unascertained modified peptides.  These peptides shouldn't inform the general protein trend, and may be interesting to analyze in isolation.
\end{itemize}

\subsection*{Algorithm structure}

\begin{itemize}
\item[\textbf{X}:] [I $\cdot$ C] Data matrix: Input MS data of the relative abundance of each peptide across C conditions
\item[\textbf{M}:] [I $\cdot$ J] Possible mappings between peptides (I) and proteins (J)
\item[$\mathbf{\Theta}$:] [I $\cdot$ K] Responsibility matrix: prob that peptide i belongs to protein j or shows a divergent trend which should be described separately.  K = I + J
\item[$\mathbf{\Omega}$:] [K $\cdot$ C] Point estimate for each species$\cdot$condition.
\item[$\sigma^{2}$:] [I] Fitted variance relative to peptide IC.
\end{itemize}

\begin{align}
p(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &\propto \prod_{i}^{I}\prod_{c}^{C} \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i}) \cdot \mathbf{\Theta}p(\mathbf{\Theta})\notag\\
\textit{l}(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &= \sum_{i}^{I}\sum_{c}^{C} \textit{ln}\left( \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i})\right)\notag\\
+ \sum_{i}^{I}\sum_{k}^{K}\mathbf{\Theta_{ik}}p(\mathbf{\Theta_{ik}})
\end{align}


\subsection{Updating $\mathbf{\Theta}$}

\begin{align}
\mathbf{\Theta}_{ik} \sim \frac{\textbf{N}(\mathbf{\Omega}_{kC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ik})}{\sum_{b = 1}^{K}\textbf{N}(\mathbf{\Omega}_{bC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ib})}
\end{align}

\subsection{Updating $\mathbf{\Omega}$}

$\tau_{y} = \prod_{z \neq y}^{Y}\sigma^{2}_{z}$

\begin{align}
\mathbf{\Omega}_{kc} \sim \mbox{\Large \textbf{N}}\left(\mu = \frac{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\textbf{X}_{ic}\tau_{i}}{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\tau_{i}}, \sigma^{2} =  \left(\sum_{i = 1}^{I}\frac{\mathbf{\Theta}_{ik}}{\sigma^{2}_{i}}\right)^{-1} \right)
\end{align}

\subsubsection*{Notes}

\begin{itemize}
\item For every protein that only has peptides that are shared by other proteins, there is little evidence that this protein exists unless the shared peptides exhibit a trend that diverges from the behavior of the shared proteins (as determined by its unique peptides).  
\end{itemize}



\subsection*{Algorithm Implementation}

\scriptsize

<<EMprep>>=	
			
### Iteration ###

prerun_fixed_mat <- TRUE

### Initalization ###
n_prot <- length(unique_mappingMat[1,])
n_p <- length(unique_mappingMat[,1])


prior_bound <- 0.9999
prior_p_div <- exp(-1*qchisq(prior_bound, n_c))  ### this should probably be adjusted to the number of conditions a peptide was measured in

#if a putative protein only has component peptides which are matched to other proteins then penalize any assignment to it by the supremum of the mixing fraction

if((unq_matches_only == TRUE & file.exists("EMoutputUnq.Rdata"))|(unq_matches_only == FALSE & file.exists("EMoutputDeg.Rdata"))){
	if(unq_matches_only == TRUE){
		load("EMoutputUnq.Rdata")
			}else{
			load("EMoutputDeg.Rdata")
			}
	}else{
	save(unq_matches_only, prerun_fixed_mat, prior_p_div, uniquePepMean, uniquePepPrecision, unique_mappingMat, n_p, n_prot, n_c, file = "EMimport.Rdata")
	#system("R64 callEM.R")

	}


#prot_abund_final <- prot_abund[,c(1:n_prot)[matched_prots]]
prot_abund_final <- prot_abund
mixing_fract[likdiff_df$matched == "Divergent-trend",] <- 0

#remove proteins that were subsumable or poorly fit (reevaluate this second part when replicates are available)
alpha_pres[alpha_pres == 1][colSums(mixing_fract) == 0] <- 0
prot_abund_final <- prot_abund_final[,!(colSums(mixing_fract) == 0)]
prot_prec <- prot_prec[,!(colSums(mixing_fract) == 0)]
possibleMap <- Matrix(unique_mappingMat[,alpha_pres == 1] == 1)
mixing_fract <- mixing_fract[,!(colSums(mixing_fract) == 0)]

prot_abund_final[prot_abund_final == 0] <- NA

n_prot <- length(prot_abund_final[1,])	
@




\normalsize
After carrying out EM, \Sexpr{sum(alpha_pres == 0)} proteins were discarded because they overlapped ascertained proteins and had no strong solitary evidence of being present.  This leaves\Sexpr{n_prot} proteins for further analysis.  


\begin{figure}
<<pepResp, echo = FALSE>>=
#how many peptides are informing a protein trend, with only the largest effect considered
max_state <- apply(mixing_fract, 1, which.max)
barplot(table(table(max_state[max_state <= n_prot])))
@
\caption{Number of peptides that are informing a protein trend, with only the largest effect considered}
\end{figure}

<<results = "asis", echo = FALSE, >>=
xtable(table(div_max), caption = "Number of peptides not-conforming to some general protein trend")
@

\begin{figure}
<<EMlikplot, echo = FALSE>>=
plot(log(abs(diff(whole_data_logL))), xlab = "Iteration", ylab = "log change in log-likelihood", pch = 16)
@
\caption{Log-likelihood of EM.  First stage (black) allows for a peptide to partially match proteins and partially diverge from the trend, the second stage (orange) thresholds such that a peptide is entirely accounted for by protein trends or entirely departs from plausible trends}
\end{figure}

\begin{figure}
<<div_match_comp, dependson = "EMprep", echo = FALSE>>=
likdiff_plot <- ggplot(likdiff_df, aes(x = likelihood, fill = matched))
likdiff_plot + geom_histogram()
@
\caption{difference between the log-likelihood of a peptide-protein match and a peptide failing to match.  Matches are colored teal and non-matched orange}
\label{likdiff_plot}
\end{figure}

\normalsize

Peptides that conform to a protein well will have a moderately high log-likelihood, bounded on the top by 0.  An alternative option is when a peptide fails to conform to a protein.  Because this protein's mean across conditions will be free, the log-likelihood of this unconstrained model will equal zero.  The difference in degrees of freedom between these two models is equal to the number of experimental conditions.  Comparing a model where the mean is constrained across \Sexpr{n_c} conditions, with it being unconstrained.  The change in log-likelihood that we would expect this constraint to cause would be $\chi^{2}_{\Sexpr{n_c}}$ distributed.  The equivalent of having a $\frac{1}{10000}$ chance of as large an increase in logL happening by chance given that a peptide actually has the same trend as a protein would be an increase in the logL of \Sexpr{qchisq(prior_bound, n_c)}.  To implicitly carry out this hypothesis during optimization, the likelihood of the peptide not matching is penalized by the subtraction of this prior and compared to the likelihood of the best peptide-protein match.  A plot of the log-likelihood difference between a fit between a peptide and the best-fitting protein is shown in figure \ref{likdiff_plot}.  

<<phosphoSiteEnrich, results = "asis", cache = TRUE>>=
### Read in phospho peptide data from phosphoGRID ###
library("stringr")

phospho_sites <- read.delim('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics/phosphosites.txt', skip = 32, header = TRUE, stringsAsFactors = FALSE)

phospho_sites_red <- phospho_sites[,colnames(phospho_sites) %in% c("A", "C", "R")]

Psites <- cbind(knownPsites(divergentPep_summary, phospho_sites_red), knownPsites(background_SRYfreq, phospho_sites_red))
colnames(Psites) <- c("Divergent", "Matched")

xtable(Psites, caption = "Number of peptides within the protein-matched and non-matched classes which contain a phosphoGRID-annotated phosphorylation site", label = "phosphoSites")
@


In order to see if divergent peptides were enriched for phosphorylation sites, they were compared with known phosphorylation sites from phosphoGRID, to determine how many of the peptide intervals of matched and non-matched peptides contained known phospho-sites.  This produced the contingency table (table \ref{phosphoSites}), which has a significant enrichment of phospho-sites (\Sexpr{round(Psites[2,1]/sum(Psites[,1]), 3)} vs. \Sexpr{round(Psites[2,2]/sum(Psites[,2]), 3)}) according to a chi-square test (p-value: \Sexpr{signif(chisq.test(Psites)$p.value)}).

Divergent peptides also appear to be associated with convoluted proteins:
<<divLengths, results = "asis">>=
valMatchCounts <- table(rowSums(sparse_mapping[pi_fit == 1,]))
divMatchCounts <- table(rowSums(sparse_mapping[pi_fit == 0,]))
matchCountsTab <- data.frame(proteinMatches = as.numeric(sort(union(names(valMatchCounts), names(divMatchCounts)))), matchCounts = 0, divergentCounts = 0)
for(val in 1:length(valMatchCounts)){matchCountsTab$matchCounts[matchCountsTab$proteinMatches == names(valMatchCounts)[val]] <- valMatchCounts[val]}
for(val in 1:length(divMatchCounts)){matchCountsTab$divergentCounts[matchCountsTab$proteinMatches == names(divMatchCounts)[val]] <- divMatchCounts[val]}

print(xtable(rbind(matchCountsTab, c("average match", signif(sum(matchCountsTab$matchCounts * matchCountsTab$proteinMatches)/sum(matchCountsTab$matchCounts), 3), signif(sum(matchCountsTab$divergentCounts * matchCountsTab$proteinMatches)/sum(matchCountsTab$divergentCounts), 3))), caption = "Divergent peptides tend to have a higher number of protein matches than peptide-protein matched peptides but this effect is small relative to the enrichment of phospho-sites"), include.rownames = FALSE)
@
  
  
\begin{figure}
<<rawHM, echo = FALSE, cache = TRUE>>=
heatmap.2(t(prot_abund_final), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(prot_abund_final, na.rm = TRUE)), max(range(prot_abund_final, na.rm = TRUE)), by = max(range(prot_abund_final, na.rm = TRUE))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM}
\end{figure}



<<MVimputeCompare, dependson = "EMrun", cache = TRUE>>=
library(missMDA)
#determine how many significant principal components should be included based on repeated random sub-sampling validation
pcrange <- c(2,18)
npc.compare <- estim_ncpPCA(prot_abund_final, ncp.min = pcrange[1], ncp.max = pcrange[2], method.cv = 'Kfold', pNA = 0.10, nbsim = 10)
npc <- (pcrange[1]:pcrange[2])[npc.compare$criterion < (max(npc.compare$criterion) - min(npc.compare$criterion))*0.01 + min(npc.compare$criterion)][1]

@



<<MVimputeData, dependson = "MVimputeCompare", cache = TRUE>>=
library(impute)

#determine the most likely values of the missing data using KNN imputation

impute_abund  <- impute.knn(as.matrix(prot_abund_final), k = 10)$data
impute_abund_thresh <- impute_abund
impute_abund_thresh[impute_abund_thresh > 5] <- 5; impute_abund_thresh[impute_abund_thresh < -5] <- -5
@

\begin{figure}
<<mvNpc, echo = FALSE>>=
plot(npc.compare$criterion ~ c(pcrange[1]:pcrange[2]), pch = 16, ylab = "MS error of prediction", xlab = "number of PCs")
abline(v = npc, col = "RED", lwd = 2)
@
\caption{Reconstruction error of raw matrix using PC-based imputation, in order to determine an appropriate number of principal components}
\end{figure}

\begin{figure}
<<impHM, echo = FALSE, cache = TRUE>>=
heatmap.2(t(impute_abund_thresh), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM and imputing missing values with missMDA}
\end{figure}

\begin{figure}
<<PC_heatmap, cache = TRUE>>=
impSVD <- svd(t(impute_abund), nu = npc, nv = npc)
impSVD_pcs <- impSVD$v
colnames(impSVD_pcs) <- paste("PC", c(1:npc))
rownames(impSVD_pcs) <- rownames(impute_abund)

heatmap.2(t(impSVD_pcs), Colv = FALSE, Rowv = FALSE, trace = "none", col = greenred(100), dendrogram = "none", colsep = c(5,10,15,21), denscol = "white")
@
\caption{Significant principal components governing variation across conditions in relative protein abundance}
\label{protPCHM}
\end{figure}

\begin{figure}
<<proteinScree>>=
plot((impSVD$d)^2 / sum((impSVD$d)^2) ~ c(1:length(impSVD$d)), pch = 16, cex = 2, col = "RED", xlab = "PC Number", ylab = "fraction of variance explained")
@
\caption{Scree plot: fraction of variance explained by PCs}
\end{figure}

<<PC_traces, cache = TRUE>>=
library(reshape)

pc_plot_df <- melt(impSVD_pcs)
colnames(pc_plot_df) <- c("condition", "PC", "value")
pc_plot_df$cond <- factor(sapply(as.character(pc_plot_df$condition), function(x){unlist(strsplit(x, ""))[1]})) 
pc_plot_df$PC <- factor(pc_plot_df$PC, levels = paste("PC", c(1:npc)))

factor_plot <- ggplot(pc_plot_df, aes(x = condition, y = value, group = cond, col = PC)) + facet_wrap(~ PC, ncol =2, scales = "free_y") + scale_x_discrete("Experimental condition") + scale_y_continuous("Principal Component Value") + theme(panel.grid.minor = element_blank(), panel.background = element_rect(fill = "aliceblue"), strip.background = element_rect(fill = "cadetblue1"), text = element_text(size = 15), axis.text.x = element_text(angle = 90), title = element_text(size = 25, face = "bold"))
factor_plot <- factor_plot + geom_line()
ggsave(plot = factor_plot, "figure/PC_traces.pdf", width = 18, height = 10)
 @

\begin{figure}[h!]
\includegraphics[scale = 0.5]{figure/PC_traces.pdf}
\caption{Principal component values of protein relative abundance matrix}
\label{PCvalTraces}
\end{figure}

<<plot_proteinTrends, dependson = "MVimputeData", cache = TRUE, warning = FALSE, cache = TRUE>>=
#tmp <- Matrix(diag(rep(prior_p_div, times = n_p))); colnames(tmp) <- paste(unique_pepNames, "divergent", sep = "_")
#tmp <- as.matrix(tmp)
#tmp[!(tmp %in% c(0,1))] <- 1 
#prior_mat_logical <- cbind(as.matrix(unique_mappingMat), tmp)
#prior_mat_logical <- prior_mat_logical == 1
#possibleMap <- Matrix(prior_mat_logical)
@

See NPT1 for a pathological example.  If all peptides are called divergent then the protein trend should be initialized as the median for each condition

\begin{figure}[h!]
<<protPlot1, dependson = c("setup", "EMprep"), warning = FALSE>>=
source("pep_library.R")
set.seed(1234)
gene_samples <- sample(c(1:n_prot), 20)
plotting_names <- orf2common(colnames(prot_abund_final))

plot_protein_lattice(gene_samples[1:5], possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 1, pi_fit)

@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}

\begin{figure}[h!]
<<protPlot2, dependson = c("setup", "EMprep"), warning = FALSE>>=
plot_protein_lattice(gene_samples[6:20], possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 3, pi_fit)
@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}

\begin{figure}[h!]
<<protPlot3, dependson = c("setup", "EMprep"), warning = FALSE>>=
#cherry-picket proteins showing condition-specific divergent peptides
pickedDivPeps <- c("YJL060W", "YJR137C", "YCR004C", "YMR027W", "YGR256W", "YGL009C", "YGL147C", "YJR121W", "YHR193C", "YER136W", "YGR253C", "YFL004W", "YOL127W")
pickedDivPeps <- pickedDivPeps[pickedDivPeps %in% colnames(prot_abund_final)][1:15]
                   
plot_protein_lattice(c(1:n_prot)[colnames(prot_abund_final) %in% pickedDivPeps], possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 3, pi_fit)
@
\caption{Putative PTMs}
\end{figure}


\section*{Metabolic proteins}

<<metGenerep, dependson = "EMprep", results = "asis", cache = TRUE>>=

rxnFile <- read.delim('~/Desktop/Rabinowitz/FBA_SRH/Yeast_genome_scale/rxn_yeast.tsv', stringsAsFactors = FALSE)
met_genes <- NULL
for(met_gene in rxnFile$MetName[is.na(rxnFile$StoiCoef)]){
	met_genes <- c(met_genes, unlist(met_gene))
	}
met_genes <- unique(met_genes)
measured_genes <- unlist(sapply(colnames(prot_abund_final), function(x){strsplit(x, "/")}))

overlapping_geneN <- length(intersect(met_genes, measured_genes))

met_gene_overlap <- data.frame(intersection = overlapping_geneN, metTot = length(met_genes), measuredTot = length(measured_genes))

print(xtable(met_gene_overlap, caption = "Investigating the overlap of metabolic enzymes (from the yeast consensus metabolic network (v5) and the proteins measured in our dataset"), include.rownames = FALSE)
@


How many metabolic genes are represented in our ascertained proteins: Using the Yeast consensus metabolic reconstruction (version 5), \Sexpr{length(met_genes)} genes involved in some reaction were assembled.  

\section*{Organellar composition driving protein abundances}

<<compartmentalizationPrep, dependson = "MVimputeData", cache = TRUE, results = "asis">>=
library(yeastExpData)
data(gfp)
col_orfNames <- colnames(impute_abund)
GFPlocalizationCols <- 11:32
                           
geneLocal <- sapply(col_orfNames, function(orfNames){
  matches <- gfp$yORF %in% strsplit(orfNames, split = '/')[[1]]
  if(sum(matches) == 0){
      rep(NA, times = length(GFPlocalizationCols))
    }else{
    colSums(gfp[matches,GFPlocalizationCols]) != 0
    }
})
#remove low frequency categories and identify unlocalized with NA
geneLocal <- geneLocal[rowSums(geneLocal, na.rm = T) > 15,]
#geneLocal[,colSums(geneLocal) == 0] <- NA
                           
localizationDF <- cbind(t(geneLocal), t(impute_abund))
localizationDFwrite <- data.frame(Gene = rownames(localizationDF), localizationDF, stringsAsFactors = FALSE)
localDF_Eweight = c("EWEIGHT", rep(0, times = length(geneLocal[,1])), rep(1, times = length(impute_abund[,1])))
localDF_Eweight <-  rbind(localDF_Eweight, localizationDFwrite)                         

compCounts <- as.data.frame(rowSums(geneLocal, na.rm = TRUE)); compCounts[,1] -> compCounts[,2]; rownames(compCounts) -> compCounts[,1]; colnames(compCounts) <- c("Compartment", "Counts")
                           
print(xtable(compCounts, display = c("s", "s", "d"), caption = "Number of protein which were found to localize to 8 sub-cellular compartment via GFP-fusions"), include.rownames = F)
@




\clearpage

\section*{Comparing protein and transcript trends}


Determine the abundance of transcripts corresponding to ascertained proteins

<<ModifyTransc, dependson = "MVimputeData", cache = TRUE, message = FALSE>>=
library(impute)

transcript_brauer <- read.delim("../brauer-microarray/Brauer_2008.pcl")
rownames(transcript_brauer) <- transcript_brauer$SYSTEMATIC_NAME
transcript_brauer <- transcript_brauer[-1,-c(1:3)]

#remove genes with many missing values
#impute missing values with KNN imputation (as per original Brauer paper)

transcript_brauer <- transcript_brauer[rowSums(!is.na(transcript_brauer)) > 0.5*length(transcript_brauer[1,]),]
transcript_brauer <- impute.knn(as.matrix(transcript_brauer), k = 10)$data
n_trans_pc <- 12
trans_svd <- svd(transcript_brauer, nu = n_trans_pc, nv = n_trans_pc)

#switch reference from C0.30 (paper says C0.25, but C0.30 is correct) to P0.05 by using fitting a n_trans_pc principal component projection of the data and then taking the difference between these two conditions for each gene.  

offset_projection <- trans_svd$u %*% diag(trans_svd$d[1:n_trans_pc]) %*% t(trans_svd$v[sapply(c("ClimD.3", "PlimD.05.2") , function(cond){c(1:length(transcript_brauer[1,]))[colnames(transcript_brauer) == cond]}),])
transc_renorm_offset <- offset_projection[,2] - offset_projection[,1]

transcript_brauer <- transcript_brauer - transc_renorm_offset


transcript.condition <- as.data.frame(matrix(NA, ncol = 36, nrow = 2))
colnames(transcript.condition) <- colnames(transcript_brauer)
rownames(transcript.condition) <- c("limitation", "GR")
limitations <- c("C", "N", "P", "S", "L", "U")
transcript.condition[1,] <- rep(limitations, each = 6)
transcript.condition[2,] <- rep(c(0.05, 0.10, 0.15, 0.20, 0.25, 0.30), times = 6)

#missing mappings
missing_on_array <- colnames(impute_abund)[!(colnames(impute_abund) %in% rownames(transcript_brauer))]
length(missing_on_array)
genes_to_compare <- colnames(impute_abund)[colnames(impute_abund) %in% rownames(transcript_brauer)]

#determine the relative abundance of array data by looking at the corresponding condition and imputing unobserved growth rates by drawing a line between the abundance of flanking conditions

tmp <- sapply(genes_to_compare, function(match){
	transcript_brauer[rownames(transcript_brauer) == match,]
	})
transcript_brauer_reduced <- matrix(unlist(tmp), ncol = length(tmp[1,]), nrow = length(tmp[,1]))
colnames(transcript_brauer_reduced) <- colnames(tmp); rownames(transcript_brauer_reduced) <- rownames(tmp)


#load true dilution rates for each of the proteomics samples
load('~/Desktop/Composition/RNA_abundance/RNAabundance.R')

prot_cond <- as.data.frame(matrix(NA, ncol = n_c, nrow = 2))
prot_cond <- sapply(rownames(impute_abund), function(cond){
	c(unlist(strsplit(cond, '[0-9]+'))[1], unlist(strsplit(cond, '[A-Z]'))[2])
	})
colnames(prot_cond) <- rownames(impute_abund)
rownames(prot_cond) <- c("limitation", "GR")
prot_cond <- as.data.frame(cbind(t(prot_cond), realDR = NA), stringsAsFactors = FALSE)
prot_cond$realDR <- sapply(1:length(prot_cond[,1]), function(cond){
	RNAabund$actual.dr[grep(paste(prot_cond$limitation[cond], prot_cond$GR[cond], sep = ""), RNAabund$condition, ignore.case = TRUE)[1]]
	})
#remove invalid conditions (not the core set)
prot_cond_bu <- prot_cond
prot_cond <- prot_cond[!is.na(prot_cond$realDR),]

DR_change_mat <- matrix(0, nrow = length(transcript.condition[1,]), ncol = length(prot_cond[,1]))
colnames(DR_change_mat) <- rownames(prot_cond); rownames(DR_change_mat) <- colnames(transcript.condition)
for(cond in 1:length(prot_cond[,1])){
	#find the 2 closest DR within the same limitation
	c_match <- c(1:length(transcript.condition[1,]))[transcript.condition[1,] %in% prot_cond[cond,]$limitation]
	flanking_match <- c_match[order(abs(as.numeric(transcript.condition[2,c_match]) - prot_cond[cond,]$realDR))[1:2]]
	lb_diff <- (prot_cond$realDR[cond] - as.numeric(transcript.condition[2,flanking_match])[1])/diff(as.numeric(transcript.condition[2,flanking_match]))
	DR_change_mat[flanking_match,cond] <- c((1-lb_diff), lb_diff)
	}
	
remapped_transc <- t(transcript_brauer_reduced) %*% DR_change_mat
@

\begin{figure}
<<transHM, dependson = "ModifyTransc", echo = FALSE, cache = TRUE>>=
heatmap.2(remapped_transc, trace = "none", Colv = NULL, dendrogram = "row", na.rm = TRUE, na.color = "white", col = greenBlackRed(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\label{Hierarchical clustering of interpolated transcript values of transcripts corresponding to ascertained proteins}
\end{figure}

<<PTcor, dependson = "ModifyTransc", cache = TRUE>>=
#measure the correlation of the transcript and protein matrix

shared_prot <- impute_abund[,(colnames(impute_abund) %in% rownames(transcript_brauer))] 
shared_prot <- shared_prot[!is.na(prot_cond_bu$realDR),]

shared_trans <- t(remapped_transc)

#center each sample #remove when normalization factor is known
shared_prot <- shared_prot - t(t(apply(shared_prot, 1, mean))) %*% t(rep(1, times = length(shared_prot[1,])))
shared_trans <- shared_trans - t(t(apply(shared_trans, 1, mean))) %*% t(rep(1, times = length(shared_trans[1,])))

pt_corrs <- sapply(c(1:length(shared_prot[1,])), function(row){
	cor(shared_prot[,row], shared_trans[,row], method = "spearman")
	}); pt_corrs <- data.frame(correlation = pt_corrs)

@

\begin{figure}[h!]
<<pairedTPheatmap, dependson = "PTcor", echo = TRUE>>=
n_c_shared <- length(shared_trans[,1])
jointTPdf <- t(rbind(shared_trans, shared_prot))[,rep(1:n_c_shared, each = 2) + rep(c(0,n_c_shared), times = n_c_shared)]
  
heatmap.2(jointTPdf, trace = "none", Colv = NULL, dendrogram = "row", na.rm = TRUE, na.color = "white", col = greenBlackRed(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250), ColSideColors = rep(c("BLUE", "YELLOW"), times = n_c_shared), main = "paired transcript and protein relative abundance")
@
\caption{Relative abundance for genes with a an unambiguous protein measured and the corresponding transcriptional changes.  Adjacent columns are pairs, with column labels reflecting: \textcolor{blue}{transcriptional changes} and \textcolor{yellow}{protein changes}.}
\end{figure}


\begin{figure}
<<globalPTcomp, dependson = "PTcor", echo = FALSE>>=
library(reshape)

pool_thresh <- 4
shared_prot_pool <- shared_prot; shared_prot_pool[shared_prot_pool < -1*pool_thresh] <- -1*pool_thresh; shared_prot_pool[shared_prot_pool > pool_thresh] <- pool_thresh
shared_trans_pool <- shared_trans; shared_trans_pool[shared_trans_pool < -1*pool_thresh] <- -1*pool_thresh; shared_trans_pool[shared_trans_pool > pool_thresh] <- pool_thresh

PTcor <- signif(c(cor(c(shared_prot), c(shared_trans), method = "pearson"), cor(c(shared_prot), c(shared_trans), method = "spearman")), 3)

PTscatterDF <- cbind(melt(shared_trans_pool), melt(shared_prot_pool)$value)
colnames(PTscatterDF) <- c("Condition", "Gene", "Transcript", "Protein")

hex_bin_max <- 500
n_hex_breaks <- 8
hex_breaks <- round(exp(seq(0, log(500), by = log(500)/8)))

hex_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "gray90"), legend.position = "top", 
  panel.grid.minor = element_blank(), panel.grid.major = element_blank(), axis.line = element_blank(), legend.key.width = unit(6, "line")) 
                           
PTscatter_plotter <- ggplot(cbind(PTscatterDF, z = 1), aes(x = Protein, y = Transcript, z = z)) + scale_x_continuous("Relative protein abundance", expand = c(0.02,0.02)) + scale_y_continuous("Relative transcript abundance", expand = c(0.02,0.02)) + scale_fill_gradient(name = "Counts", low = "black", high = "firebrick1", trans = "log", breaks = hex_breaks, labels = hex_breaks) + hex_theme
PTscatter_plotter <- PTscatter_plotter + geom_hex()
PTscatter_plotter
ggsave(plot = PTscatter_plotter, "globalPTcomp.pdf", width = 10, height = 10)
@
\caption{Global correlation between relative protein abundance and relative transcript abundance. The pearson and spearman correlations between non-thresholded relative-abundances are \Sexpr{PTcor[1]} and \Sexpr{PTcor[2]} respectively.}
\end{figure}

\begin{figure}
<<globalPTregressed, dependson = c("PTcor", "globalPTcomp"), echo = FALSE>>=
library(reshape)

protSlopes <- lm(shared_prot ~ factor(prot_cond$limitation) + factor(prot_cond$limitation) * prot_cond$realDR)$coef
protSlopes <- protSlopes[6:10,]; rownames(protSlopes) <- levels(factor(prot_cond$limitation))

transSlopes <- lm(shared_trans ~ factor(prot_cond$limitation) + factor(prot_cond$limitation) * prot_cond$realDR)$coef
transSlopes <- transSlopes[6:10,]; rownames(transSlopes) <- levels(factor(prot_cond$limitation))

PTcor <- signif(c(cor(c(protSlopes), c(transSlopes), method = "pearson"), cor(c(protSlopes), c(transSlopes), method = "spearman")), 3)

pool_thresh <- 10
protSlopes[protSlopes < -1 * pool_thresh] <- -1 * pool_thresh; protSlopes[protSlopes > pool_thresh] <- pool_thresh
transSlopes[transSlopes < -1 * pool_thresh] <- -1 * pool_thresh; transSlopes[transSlopes > pool_thresh] <- pool_thresh


PTscatterDF <- cbind(melt(protSlopes), melt(transSlopes)$value)
colnames(PTscatterDF) <- c("Condition", "Gene", "Transcript", "Protein")

hex_bin_max <- 500
n_hex_breaks <- 8
hex_breaks <- round(exp(seq(0, log(500), by = log(500)/8)))

PTscatter_plotter <- ggplot(cbind(PTscatterDF, z = 1), aes(x = Protein, y = Transcript, z = z)) + scale_x_continuous("Relative protein abundance", expand = c(0.02,0.02)) + scale_y_continuous("Relative transcript abundance", expand = c(0.02,0.02)) + scale_fill_gradient(name = "Counts", low = "black", high = "firebrick1", trans = "log", breaks = hex_breaks, labels = hex_breaks) + hex_theme
PTscatter_plotter + geom_hex()  

@
\caption{Correlation between by-condition slopes protein and transcript relative abundance. The pearson and spearman correlations between non-thresholded relative-abundances are \Sexpr{PTcor[1]} and \Sexpr{PTcor[2]} respectively.}
\end{figure}




\begin{figure}
<<PTspearcorr, dependson = "PTcor", echo = FALSE>>=

hist_theme <- theme(text = element_text(size = 23, face = "bold"), title = element_text(size = 25, face = "bold"), panel.background = element_rect(fill = "aliceblue"), legend.position = "none", 
  panel.grid.minor = element_blank(), panel.grid.major = element_blank(), axis.line = element_blank(), axis.title.x = element_text(vjust = -0.1), axis.title.y = element_text(vjust = 0.3)) 

plotted_count_max <- max(table(cut(pt_corrs$correlation,seq(min(pt_corrs$correlation),max(pt_corrs$correlation),0.04)))) 
                           
cor_plot <- ggplot(pt_corrs, aes(x = correlation)) + hist_theme
cor_plot <- cor_plot + scale_x_continuous(name = "Spearman Correlation", expand = c(0,0), limits = c(-1,1), breaks = seq(-1, 1, 0.2)) + scale_y_discrete(name = "Counts", expand = c(0,0), breaks = (0:ceiling(plotted_count_max/5))*5) + geom_histogram(colour = "aliceblue", fill = "limegreen", binwidth = 0.04)
ggsave(plot = cor_plot, "figure/PTspearmans.pdf", width = 12, height = 16)

#generate a null distribution of spearman correlations via permutaiton testing
perms <- 1000
#generate a matrix of permutation indices
spearCorrNULL <- matrix(NA, ncol = perms, nrow = length(shared_prot[1,]))
for(gene in 1:length(shared_prot[1,])){
  #permute protein pattern w.r.t. transcript pattern
  sampleIndices <- sapply(1:perms, function(perm){sample(1:length(shared_prot[,1]), length(shared_prot[,1]))})
  permutedData <- apply(sampleIndices, 2, function(permDat){shared_prot[permDat,gene]})
  spearCorrNULL[gene,] <- apply(permutedData, 2, function(nullCorr){cor(nullCorr, shared_trans[,gene], method = "spearman")})
}

nullSpears <- melt(spearCorrNULL); colnames(nullSpears) <- c("gene", "permutation", "correlation")
cor_plotNULL <- ggplot(nullSpears, aes(x = correlation)) + hist_theme + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
cor_plotNULL <- cor_plotNULL + scale_x_continuous(name = "Spearman Correlation", expand = c(0,0), limits = c(-1,1), breaks = seq(-1, 1, 0.2)) + scale_y_discrete(name = "Counts", expand = c(0,0)) + geom_histogram(colour = "aliceblue", fill = "chocolate1", binwidth = 0.04)
ggsave(plot = cor_plotNULL, "figure/PTspearmansNULL.pdf", width = 12, height = 16)


#two tailed test using permutations to establish which correlations are discoveries
library(qvalue)

spearPvalue <- sapply(1:length(shared_prot[1,]), function(spearp){
  sum(pt_corrs$correlation[spearp] <= spearCorrNULL[spearp,])/perms
  })
spearPvalue_twotailed <- 1 - abs((0.5 - spearPvalue)*2)
corrQval <- qvalue(spearPvalue_twotailed) 
corrQval$pi0  

pt_corrs$significant <- corrQval$qvalues <= 0.05

cor_plot <- ggplot(pt_corrs, aes(x = correlation, fill = significant)) + hist_theme
cor_plot <- cor_plot + scale_x_continuous(name = "Spearman Correlation", expand = c(0,0), limits = c(-1,1), breaks = seq(-1, 1, 0.2)) + scale_y_discrete(name = "Counts", expand = c(0,0), breaks = (0:ceiling(plotted_count_max/5))*5) + geom_histogram(colour = "aliceblue", binwidth = 0.04) + scale_fill_manual(name = "Correlation Significance", values = c("TRUE" = "limegreen", "FALSE" = "orange"))
ggsave(plot = cor_plot, "figure/PTspearmansSig.pdf", width = 12, height = 16)


@
\caption{Distribution of spearman correlations across transcript-protein pairs}
\end{figure}

To determine which correlations between proteins and transcript relative abundances were more positively- or anti-correlated than we would expect by chance, a null distribution of correlations for each gene was found by permutation testing.  Briefly, for each gene: transcript relative abundances were fixed and for each of \Sexpr{perms} permutations, corresponding protein relative abundances were samples without replacement.  P-values were found as the quantile of the observed spearman correlation relative to the null permutaitons.  Across the \Sexpr{pt_corrs$significant} genes, the expected fraction of true null correlations was found to be \Sexpr{round(corrQval$pi0, 3)}.  Of the correlations that deviated from this null trend, \Sexpr{sum(pt_corrs$correlation[pt_corrs$significant] > 0)} and \Sexpr{sum(pt_corrs$correlation[pt_corrs$significant] < 0)} were more positive and negative respectively than would be expected by chance.  



<<fileDump1, dependson = "c(mvmat_red, mv_impute, PTcor)", echo = TRUE, cache = TRUE, warning = FALSE>>=
#file dump
#add gene descriptions
#This part runs slowly because each entry needs to be parsed seperately so an error is not returned when indeces fail to match
                           
#Missing value matrix                           
prot_missingVal_desc <- cond_peps
gene_desc <- sapply(rownames(cond_peps), function(gene){try(orf2desc(unlist(strsplit(gene, split = '[/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- sapply(names(gene_desc)[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})], function(gene){try(orf2desc(unlist(strsplit(gene, split = '[-/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- "No Annotation"
rownames(prot_missingVal_desc) <- unname(gene_desc)

#Imputed relative abundance matrix
imput_abund_desc <- impute_abund
gene_desc <- sapply(colnames(imput_abund_desc), function(gene){try(orf2desc(unlist(strsplit(gene, split = '[/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- sapply(names(gene_desc)[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})], function(gene){try(orf2desc(unlist(strsplit(gene, split = '[-/]'))[1]), silent = TRUE)})
gene_desc[sapply(gene_desc, function(gene){ifelse(strsplit(gene, split = " ")[[1]][1] == "Error", TRUE, FALSE)})] <- "No Annotation"
colnames(imput_abund_desc) <- unname(gene_desc)

impute_abund_names <- colnames(impute_abund)
impute_abund_degenNames <- impute_abund
colnames(impute_abund) <- unname(sapply(colnames(impute_abund), function(x){strsplit(x, split = "/")[[1]][1]}))

localDF_Eweight$Gene[-1] <- colnames(imput_abund_desc)                           
                           
if(unq_matches_only == TRUE){
write.output(prot_missingVal_desc, "run_Unq/mvMatrix.tsv")
write.output(uq_binPepMatrix[!(apply(uq_binPepMatrix != 0, 1, sum) %in% c(0,length(uq_binPepMatrix[1,]))),], "run_Unq/mvMatrixpeps.tsv")
write.output(t(imput_abund_desc), "run_Unq/relAbundMatrix_desc.tsv")
write.output(t(impute_abund), "run_Unq/relAbundMatrix.tsv")
write.output(t(shared_prot - shared_trans), "run_Unq/TPdiffMatrix.tsv")
write.table(localDF_Eweight, file = "run_Unq/localDF_Eweight.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

save(n_prot, prot_abund_final, prot_prec, conditions, file = "run_Unq/protLMfile.Rdata")
}
if(unq_matches_only == FALSE){
write.output(prot_missingVal_desc, "run_Deg/mvMatrix.tsv")
write.output(uq_binPepMatrix[!(apply(uq_binPepMatrix != 0, 1, sum) %in% c(0,length(uq_binPepMatrix[1,]))),], "run_Deg/mvMatrixpeps.tsv")
write.output(t(imput_abund_desc), "run_Deg/relAbundMatrix_desc.tsv")
write.output(t(impute_abund), "run_Deg/relAbundMatrix.tsv")
write.output(t(shared_prot - shared_trans), "run_Deg/TPdiffMatrix.tsv")
write.output(t(shared_trans), "run_Deg/Trans_shared.tsv")
write.output(transcript_brauer, "run_Deg/Trans_all.tsv")
#save(n_prot, prot_abund, prot_prec, conditions, file = "run_Deg/protLMfile.Rdata") #switched to prot_abund_final ?
write.table(localDF_Eweight, file = "run_Deg/localDF_Eweight.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
save(n_prot, prot_abund_final, prot_prec, conditions, file = "run_Unq/protLMfile.Rdata")
}
@






Determine how many clusters should be used for K-means clustering of protein abundance \& protein - transcript difference matrices.
<<kmeansNclust, dependson = "transHM", cache = TRUE>>=

kvals <- c(2:30)
data_clust <- stepFlexclust(t(impute_abund), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_prot <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})
	
data_clust <- stepFlexclust(t(shared_prot - shared_trans), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_pt <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})	
	
@

<<kmeanBarplot, dependson = "kmeansNclust", warning = FALSE, echo = FALSE>>=
plot_df <- data.frame(WICSSdiff = c(-1*diff(WICSS_prot), -1*diff(WICSS_pt)), nclusters = rep(kvals[-length(kvals)], times = 2), class = rep(c("Protein Abundance", "Protein - Transcript Abundance"), each = (length(kvals) - 1)))

clusterN_plot <- ggplot(plot_df, aes(x = nclusters, y = WICSSdiff)) + facet_grid(class ~ ., scales = "free_y")
clusterN_plot + geom_bar(stat = "identity")
@


Read in cluster assignments from Cluster2.0

<<prot_clust>>=

if(unq_matches_only == TRUE){
	prot_kmeans_ass <- read.delim("run_Unq/relAbundMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	prot_kmeans_ass <- read.delim("run_Deg/relAbundMatrix_K_G20.kgg")
	}

clusteredDat <- t(impute_abund)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(prot_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}
	
nclust <- length(unique(prot_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% prot_kmeans_ass[,1][prot_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	prot_kmeans_ass$GROUP[prot_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df1 <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}[h!]
<<protclustplot, dependson = "prot_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df1, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins in a cluster (teal) and the centroid itself (orange)}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in protein-abundance clusters}
\label{prot_FIRE}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/trans_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in transcript-abundance clusters}
\label{trans_FIRE}
\end{figure}


\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_iPAGE_GO.pdf}
\caption{iPAGE-GO output, performing gene-set enrichment analysis on protein-abundance clusters}
\label{prot_GO}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/prot_var_iPAGE_KEGG.pdf}
\caption{iPAGE-KEGG output, searching for enrichment of metabolic processes in protein-abundance clusters}
\label{prot_KEGG}
\end{figure}


<<tn_clust>>=

if(unq_matches_only == TRUE){
	pt_kmeans_ass <- read.delim("run_Unq/TPdiffMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	pt_kmeans_ass <- read.delim("run_Deg/TPdiffMatrix_K_G20.kgg")
	}

clusteredDat <- t(shared_prot - shared_trans)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(pt_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}

n_c <- length(clusteredDat[1,])
nclust <- length(unique(pt_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% pt_kmeans_ass[,1][pt_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	pt_kmeans_ass$GROUP[pt_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df2 <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}
<<tnclustplot, dependson = "tn_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df2, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins - transcript differences; clusters (teal) and the centroid itself (orange)}
\end{figure}

\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_FIRE.pdf}
\caption{FIRE output, searching for DNA regulatory motif enrichment in protein-transcript difference clusters}
\label{TP_FIRE}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.4]{run_Deg/TPdiff_FIREpro.pdf}
\caption{FIRE-prot output, searching for enrichment of amino acid motifs in the primary sequence of proteins within protein-transcript difference clusters}
\label{TP_FIREpro}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_iPAGE_GO.pdf}
\caption{iPAGE-GO output, performing gene-set enrichment analysis on protein-transcript difference clusters}
\label{TP_GO}
\end{figure}

\vspace{-40mm}
\begin{figure}[h!]
\includegraphics[scale = 0.5]{run_Deg/TPdiff_iPAGE_KEGG.pdf}
\caption{iPAGE-KEGG output, searching for enrichment of metabolic processes in protein-abundance clusters}
\label{TP_KEGG}
\end{figure}


\clearpage

\section*{Looking for condition and growth-rate specific changes in protein abundance}

<<regSumImport>>=
#using the protLMfile files saved, cond_trend_regressions.R is run

load("protRegressions.Rdata")
n_bs_t <- 5000
n_bs_f <- 1000
FDR_desired <- 0.05
@


Two types of models were fitted to each protein's relative abundance across the 25 conditions.  

\textcolor{blue}{\circled{1}} \textbf{Fitting a condition-specific slope and intercept and testing whether $\beta/\alpha$ != 0 using a pivotal t-statistic approach.}

\begin{equation}
y_{i} = \beta^c \cdot DR_{i} + \alpha^c + \epsilon_{i}
\end{equation}

<<protSum1, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$prot_tstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Protein variation analyzed with t-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\textcolor{blue}{\circled{2}} \textbf{An F-statistic based approach to compare nested models}

Test condition-specific differences in offset (one condition has a different offset from all others)
\begin{align}
H_{1} &= \beta \cdot DR_{i} + \alpha^{c/-c} + \epsilon_{i}\\
H_{0} &= \beta \cdot DR_{i} + \alpha + \epsilon_{i}
\end{align}

Test for condition-specific slope (one condition has a different slope from all others)
\begin{align}
H_{1} &= \beta^{c/-c} \cdot DR_{i} + \alpha^c + \epsilon_{i}\\
H_{0} &= \beta \cdot DR_{i} + \alpha^c + \epsilon_{i}
\end{align}

<<protSum2, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$prot_Fstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Protein variation analyzed with F-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\clearpage
The same procedure was used on the divergent peptides

<<protSum3, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$divpep_tstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Divergent peptide variation analyzed with t-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

<<protSum4, dependson = "regSumImport", results = "asis", echo = FALSE>>=
xtable(protRegressions$divpep_Fstat$FDR_stats, display = c("s", "f", "g", "d"), digits = 3, caption = "Divergent peptide variation analyzed with F-statistics, discovery summary, showing the number of coefficients with a non-zero effect size")
@

\subsection*{Investigating specific examples of protein patterns departing from transcriptional patterns}

\textbf{Starting by looking at the best versus the worst, in terms of protein(peptide) patterns}

<<badCorrCompare1, dependson = "PTcor">>=
spearCounts <- 5

gene_index <- c(order(pt_corrs$correlation)[1:spearCounts],
order(abs(pt_corrs$correlation))[1:spearCounts],
order(pt_corrs$correlation)[(length(pt_corrs[,1]) - (spearCounts - 1)):length(pt_corrs[,1])])
                             
dispartecors <- pt_corrs$correlation[gene_index]
corrClass <- rep(c("anticorrelated", "uncorrelated", "correlated"), each = spearCounts)        
                           
prot_abundMatchedIndex <- sapply(colnames(shared_prot)[gene_index], function(match_it){c(1:length(prot_abund_final[1,]))[colnames(prot_abund_final) == match_it]})

@

\begin{figure}[h!]
<<dispProtPlot, dependson = c("badCorrCompare1", "protPlot1"), warning = FALSE>>=
source("pep_library.R")

plot_protein_lattice(unlist(prot_abundMatchedIndex), possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, conditions, label_phospho = TRUE, phospho_lib = phospho_sites_red, plotting_names = plotting_names, num.cols = 5, pi_fit)
@
\caption{relative protein abundance and peptide trends contributing to protein trend}
\end{figure}


\begin{figure}[h!]
<<dispProtScatter, dependson = c("badCorrCompare1", "setup")>>=
shared_prot_tmp <- shared_prot[,gene_index]; shared_trans_tmp <- shared_trans[,gene_index]
colnames(shared_prot_tmp) <- colnames(shared_trans_tmp) <- unname(orf2common(colnames(shared_prot)[gene_index])) 
                           
divCompDf <- cbind(melt(shared_prot_tmp), melt(shared_trans_tmp)[,3])
colnames(divCompDf) <- c("condition", "gene", "Protein_Abundance", "Transcript_Abundance")
divCompDf$limitation <- sapply(as.character(divCompDf$condition), function(el){strsplit(el, split = "")[[1]][1]})
divCompDf$gene <- factor(divCompDf$gene, levels = colnames(shared_prot_tmp))
divCompDf$class <- rep(corrClass, each = length(shared_prot_tmp[,1]))

scatter_facet_theme <- theme(text = element_text(size = 16, face = "bold"), title = element_text(size = 20, face = "bold"), panel.background = element_blank(), legend.position = "top", 
  panel.grid.minor = element_blank(), panel.grid.major = element_line(size = 0.5)) 
                                                      
divScatterPlot <- ggplot(divCompDf, aes(x = Transcript_Abundance, y = Protein_Abundance, col = factor(limitation), fill = factor(limitation))) + scatter_facet_theme  + facet_wrap(~ gene, ncol = 5, scales = "free")# +  facet_grid(class ~ ., margins = "gene") 
print(divScatterPlot + geom_point(aes(size = 2)) + scale_x_continuous(name = "Transcript relative abundance") + scale_y_continuous(name = "Protein relative abundance") + scale_colour_discrete(guide = "none") + scale_fill_discrete(name = "Limitation") + scale_size_continuous(guide = "none") + geom_smooth(method = lm, aes(fill = factor(limitation), alpha = as.numeric(0))) + scale_alpha_continuous(guide = "none", range = c(0.2,0.2)))

@

\caption{Comparison of the transcriptional versus protein relative abundance patterns for the most poorly-correlated and well-correlated examples}
\end{figure}

Poorly correlated tend to have very little change across conditions, so signal:noise is lower.\\
well correlated tend to have many more peptides measured - plot number of peptides versus correlation or mean(precision) versus correlation


\textbf{Do continuous GO on the spearman correlation}
%<<>>=
%entrez_pt_corrs <- pt_corrs; rownames(entrez_pt_corrs) <- orf2entrez(colnames(shared_prot))
%write.table(entrez_pt_corrs, file = "run_Deg/spearmanCorr.tsv", sep = "\t", row.names = TRUE, col.names = TRUE, quote = FALSE)
%run Arjun python script
%@

<<gseaCorrMF>>=
gseaCorrMF <- read.table('contGSEA/spearmanCorr-gobp_yeast.closed.zscore.mat', sep = "\t", header = TRUE)
gseaCorrMotif <- read.table('contGSEA/spearmanCorr-interpro_yeast_entrez.zscore.mat', sep = "\t", header = TRUE)

@


%<<GSEA_corr_MF, include = FALSE>>=
%nbreaks = 100
%hist(gseaCorrMF[,4], breaks = nbreaks, main = "GSEA Z-scores versus null expectation", xlab = "Z scores (Wald statistics)")
%lines(dnorm(seq(range(gseaCorrMF[,4])[1], range(gseaCorrMF[,4])[2], by=diff(range(gseaCorrMF[,4]))/1000), 0, 1)*length(gseaCorrMF[,1])*diff(range(gseaCorrMF[,4]))/nbreaks ~ seq(range(gseaCorrMF[,4])[1], range(gseaCorrMF[,4])[2], by=diff(range(gseaCorrMF[,4]))/1000), lwd =3, col = "BLUE")
% @

\begin{figure}[h!]
\centering
\includegraphics[scale = 0.8]{figure/GSEA_corr_MF.pdf}
\caption{PAGE analysis of spearman correlations between patterns of protein and transcript relative variation for the the same genes - negative scores indicate enrichment of a gene-set within more-negative spearman correlations and positive suggests an association with greater positive-correlations.  The histogram indicates the actual distribution of GO-term Z-scores and the curve indicates the null expectati that these values will follow a N(0,1) distribution}
\label{GSEA_PTcorrDat}
\end{figure}

\section*{Interesting notes and representative examples}

\begin{itemize}
\item[YGL009C: LEU1] - up in leucine limitation and one-peptide is down (consistent with an increase in phosphorylation)
\item[YGR253C: PUP2] - 20S proteasome involved in ubiquitin-dependent catabolism - one peptide is very high in low Nitrogen-lim and high in Leucine-lim.
\item[on FIRE] FIRE detects a substantial number of transcriptional regulatory motifs in the proteomics (figure \ref{prot_FIRE}) and transcriptional datasets.  This is contrasted with paucity of protein motifs (none).  This trend is reversed when looking at patterns in the ratio of Protein/Transcript, where there are few transcriptional motifs (figure \ref{TP_FIRE}) and many protein motifs (figure \ref{TP_FIREpro}). 	
\end{itemize}
\end{document}  
