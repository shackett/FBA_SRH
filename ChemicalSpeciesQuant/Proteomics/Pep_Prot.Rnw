\documentclass[12pt]{article}
\usepackage[left=0.95in,top=0.95in,right=0.95in,bottom=0.95in,nohead]{geometry}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{wrapfig}	%in-line figures
\usepackage[numbers, super]{natbib}		%bibliography
%\usepackage{pslatex} 	%for times new roman
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{aurical}
\usepackage[scaled]{helvet}
\usepackage{multicol}
\usepackage{upquote}

\Sexpr{opts_chunk$set(tidy=TRUE, message=FALSE)}
<<echo=FALSE,results='hide'>>=
options(width=80)
library(knitr)

setwd('~/Desktop/Rabinowitz/FBA_SRH/ChemicalSpeciesQuant/Proteomics')
load('20120807ProtPepMatrices.Rdata')
source("pep_library.R")
plotting_fxn()
matrix_fxn()

blackOrange <- function(n){colorpanel(n, "black", "black", "orange")}
greenBlackRed <- function(n){colorpanel(n, "green", "black", "red")}

@


\author{Sean R. Hackett}
\title{Aggregator: Peptides to Protein EM and analysis} 
\date{}

\begin{document}

\setlength{\parskip}{0.5mm}
\linespread{1}

\thispagestyle{empty}
\pagestyle{empty}

\maketitle


\section*{Data Processing}

\small

<<dataImp, cache=TRUE>>=

quality_frac <- 0.8
ICthreshold <- 2^15
#only consider peptides that match unambiguously to a single protein
unq_matches_only <- FALSE

lightIC[lightIC < ICthreshold] <- NA; heavyIC[heavyIC < ICthreshold] <- NA

good_samples <- rowSums(is.finite(PepMatrix) & !is.na(lightIC) & !is.na(heavyIC)) >= (length(PepMatrix[1,])*quality_frac)

#possible mappings between a protein and all matching peptides
mappingMat <- ProtPepMatrix[good_samples,]
nsharedpep <- table(rowSums(mappingMat))

if(unq_matches_only){
	good_samples[good_samples] <- good_samples[good_samples] & (rowSums(mappingMat) == 1)
	mappingMat <- ProtPepMatrix[good_samples,]
	}
mappingMat <- mappingMat[,colSums(mappingMat) != 0]

#combine degenerate proteins together if all the peptides associated with multiple proteins are shared

degen_prots <- apply(mappingMat, 2, function(prot){
	paste(prot, collapse = "")
	})

degen_prot_patterns <- names(table(degen_prots))[unname(table(degen_prots)) > 1]

degen_prot_matches <- list()
degen_mappings <- NULL
for(pat in 1:length(degen_prot_patterns)){
	
	degen_prot_matches[[paste(colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]], collapse = "/")]] <- colnames(mappingMat)[degen_prots %in% degen_prot_patterns[pat]]
	degen_mappings <- cbind(degen_mappings, mappingMat[,degen_prots %in% degen_prot_patterns[pat]][,1])
	
	}
colnames(degen_mappings) <- names(degen_prot_matches)	

mappingMat <- cbind(mappingMat[,!(degen_prots %in% degen_prot_patterns)], degen_mappings)	
	


#the relative abundance of a peptide across conditions w.r.t a common reference
abundMat <- PepMatrix[good_samples,]
good_light <- lightIC[good_samples,]
good_heavy <- heavyIC[good_samples,]

#map measured peaks to unique peptide sequences

pepNames <- rownames(mappingMat)
unique_NameCorr <- sapply(pepNames, function(name){
	unlist(strsplit(name, "\\."))[1]
	})
unique_pepNames <- unique(unique_NameCorr)
unique_NameCorrCol <- sapply(unique_NameCorr, function(name){
	c(1:length(unique_pepNames))[name == unique_pepNames]
	})

pepToUniq <- matrix(0, nrow = length(pepNames), ncol = length(unique_pepNames))
rownames(pepToUniq) <- pepNames; colnames(pepToUniq) <- unique_pepNames
for(i in 1:length(pepNames)){
	pepToUniq[i,unique_NameCorrCol[i]] <- 1
	}
pepToUniq <- Matrix(pepToUniq)

#determine the expectation of the standard deviation as a heteroschedastic fxn of IC using p0.05 light v. p0.05 heavy

avgSignalSTD <- apply(cbind(heavyIC[,colnames(heavyIC) == "P0.05"], lightIC[,colnames(lightIC) == "P0.05"]), 1, mean)
logLight <- log2(lightIC[is.finite(avgSignalSTD),colnames(lightIC) == "P0.05"])
logHeavy <- log2(heavyIC[is.finite(avgSignalSTD),colnames(heavyIC) == "P0.05"])
avgSignalSTD <- avgSignalSTD[is.finite(avgSignalSTD)]
#remove this step to increase variance, since this factor isnt known in principle
logLight <- logLight + optimize(normFactor, c(-1, 1), logLight = logLight, logHeavy = logHeavy)$minimum

#variance of the replicate differences accounting for small sample (scaling factor of 2)
STDvar <- (logLight - logHeavy)^2*2
STDvar_fit <- lm(log2(STDvar) ~ log2(avgSignalSTD))$coef

@

\begin{itemize}
\item Remove all peptides with more than \Sexpr{1 - quality_frac} fraction of missing data
\item Remove all peptides with less than \Sexpr{ICthreshold} ions measured
\item This results in \Sexpr{table(good_samples)[names(table(good_samples)) == TRUE]} peptides that are retained and \Sexpr{table(good_samples)[names(table(good_samples)) == FALSE]} peptides which are discarded.
\end{itemize}

Some of the proteins are totally degenerate, i.e. all of the peptides that match them, also match one or more other effectively identical proteins.  To deal with this, These degenerate proteins were combined and the mapping matrix (of peptides - proteins) was consolidated removing these degeneracies, the degenerate proteins were then combined and named according to the genes that they encompass.  These proteins shouldn't be used for transcript $\sim$ protein association, but will be useful for other purposes.

\begin{figure}[h!]
<<repdiffplot1, dependson = "dataImp", echo = FALSE>>=
gplot.hexbin(hexbin(logLight, logHeavy, xbins = 200), colramp = rainbow)
@
\label{heavylightcomp}
\caption{Comparison of log$_{2}$p0.05$^{H}$ and log$_{2}$p0.05$^{L}$}
\end{figure}

<<ICsdreg1, dependson = "dataImp", echo = FALSE, include = FALSE>>=
plot(log2(STDvar) ~ log2(avgSignalSTD), pch = 16, cex = 0.3)
abline(STDvar_fit, col = "RED")
@

<<ICsdreg2, dependson = "dataImp", echo = FALSE, include = FALSE>>=
gplot.hexbin(hexbin(log2(avgSignalSTD), log2(STDvar), xbins = 80), colramp = rainbow)
@


\begin{figure}[h!]
\begin{center}
\subfloat[Linear regression]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg1.pdf}
}
\qquad
\subfloat[Bivariate histogram: residual variance is a decreasing function of signal strength]{
\includegraphics[width=0.4\textwidth]{figure/ICsdreg2.pdf}}
\end{center}
\label{repFitSD1}
\caption{$\epsilon^{2}$ versus average log$_{2}$ ion counts of the heavy and light peak}
\end{figure}

<<pooled_variance, dependson = "dataImp">>=

meanCtrlIC <- mapply(mean, logHeavy, logLight)
nbins <- 100
binsize <- floor(length(meanCtrlIC)/nbins)
error_bins <- data.frame(val_mean = meanCtrlIC[order(meanCtrlIC)], light_val = logLight[order(meanCtrlIC)], bin = c(rep(1:(length(meanCtrlIC) %% nbins), each = binsize + 1), rep(((length(meanCtrlIC) %% nbins) + 1):nbins, each = binsize)))

bin_var <- data.frame(logIC = rep(NA, times = nbins), MLE_var = rep(NA, times = nbins),  MLE_var2 = rep(NA, times = nbins))
bin_dist_plot <- NULL

for(bin in 1:nbins){
	bin_var$logIC[bin] <- mean(error_bins[error_bins$bin == bin,]$val_mean)
	
	#calculate unbiased estimate of variance
	resid_dist <- (error_bins[error_bins$bin == bin,]$light_val - error_bins[error_bins$bin == bin,]$val_mean)*sqrt(2)
	#get the average residual magnitude and then square for the varianace
	bin_var$MLE_var2[bin] <- mean(abs(resid_dist[abs(resid_dist) < sd(resid_dist)*3]))^2
	
	}

var_spline <- smooth.spline(x = bin_var$logIC, y = bin_var$MLE_var2, df = 5)

@

\begin{figure}
<<pooled_var_plot, echo = FALSE>>=
plot(var_spline, type = "l", lwd = 2, ylim = c(0, range(c(predict(var_spline, bin_var$logIC)$y, bin_var$MLE_var2))[2]))
points(bin_var$logIC, bin_var$MLE_var2, pch = 16, cex = 0.8, col = "RED")
@
\caption{pooling peptides by mean($log_{2}^{H}, log_{2}^{L}$) and within these pools looking at the average variance}
\label{poole_var_fig}
\end{figure}

From the results above, the variance of peptide abundances is clearly a decreasing function of peak size.  In order to form a more robust estimate of variance as a function of ion-count, peptides were sorted by mean($log_{2}X^{H}, log_{2}X^{L}$) and pooled into \Sexpr{nbins} binds,  containing \Sexpr{binsize}-\Sexpr{binsize+1} peptides.  The variance within these bins was calculated as according to equation \ref{poolvar}, and a 5$^{th}$ degree spline was fit through these points (figure \ref{poole_var_fig}).  This estimate of V(IC) can be used as a prediction of how close a peptides relative abundance is to the population parameter of interest, the protein mean. 

\begin{align}
\epsilon_{p} &= X_{p}^{H} - X_{p}^{L}\notag\\
\sigma^{2} &= mean(|\epsilon_{p} * \sqrt{2}|)^{2}\label{poolvar}
\end{align}

\normalsize

\begin{figure}[h!]
<<nshare, dependson = "dataImp", echo = FALSE>>=
barplot(nsharedpep)
@
\caption{Number of proteins that a measured peptide matches}
\end{figure}

In order to determine the expected variance of the relative abundance of a peptide($\mathbf{X}_{ic}$ about the relative abundance of its corresponding protein ($\mathbf{\Omega}_{kc}$), we assume that $\mathbf{X}_{ic} \sim N(\mathbf{\Omega}_{kc}, \sigma^{2}_{ic}$) with $E[\sigma^{2}_{ic}]$ being fitted either from residuals or replicates.

Fitting from replicates can be done because all of the samples are quantified with respect to a common reference p0.05, including an experimental sample of p0.05.  The difference between these  





\small

<<EMsetup, dependson = "dataImp", cache = TRUE>>=

#calculate the expected sampling variance of the heavy-low diff for experimental measurement

lightHeavyCellmean <- sapply(c(1:length(heavyIC[,1]))[good_samples], function(row){
	mapply(FUN = function(a,b){
		if(!is.na(a) & !is.na(b)){mean(a, b)}else{NA}
		}, lightIC[row,], heavyIC[row,])
	})



#fittedVar <- var_calc(lightHeavyCellmean, STDvar_fit)

fittedVar <- apply(log2(lightHeavyCellmean), c(1,2), function(x){
	if(is.na(x)){NA}else{
		predict(var_spline, x)$y
		}
	})

fittedPrec <- fittedVar^-1

#for each unique peptide, combine the multiple ionization states to produce a single point estimate, using integrated likelihood

#set the precision of missing values to 0; equivalent to no impact, infinite variance

fittedPrec[t(is.na(abundMat))] <- 0
fittedPrec[is.na(fittedPrec)] <- 0
abundMat[t(fittedPrec) == 0] <- 0

n_p = length(unique_pepNames) #4042
n_prot <- length(mappingMat[1,])
n_pp = n_p + n_prot #4964
n_c = length(abundMat[1,]) #15

uniquePepMean <- matrix((((t(abundMat) * fittedPrec) %*% pepToUniq)/(fittedPrec %*% pepToUniq)), ncol = n_p, nrow = n_c)
uniquePepPrecision <- Matrix(fittedPrec %*% pepToUniq)
uniquePepMean[is.nan(uniquePepMean)] <- NA

#change mapping from peptides to unique peptides (averaging over ionization states)
unique_mappingMat <- as.matrix(t(pepToUniq) %*% mappingMat)
unique_mappingMat[!(unique_mappingMat %in% c(0,1))] <- 1
unique_mappingMat <- Matrix(unique_mappingMat)


#number of non-missing values for peptides
Nmissing_val <- table(rowSums(!is.na(t(uniquePepMean))))

uniquePepMean[is.na(uniquePepMean)] <- 0

#number of non-missing values for all peptides (before uniquenss combination)
Nmissing_val_all <- table(apply(is.finite(PepMatrix), 1, sum))

@

<<results = "asis", echo = FALSE>>=
library(xtable)
print(xtable(data.frame(Proteins = n_prot, Peptides = n_p, Conditions = n_c), display = c("s", "d", "d", "d")), include.rownames = FALSE)
@


\begin{figure}[h!]
<<mvbarplot, dependson = "EMsetup", echo = FALSE>>=
barplot(table(apply(is.finite(PepMatrix), 1, sum)), col = c(rep("darkgray", times = sum(as.numeric(names(Nmissing_val_all)) < ceiling(n_c * quality_frac))), rep("orange", times = sum(as.numeric(names(Nmissing_val_all)) >= ceiling(n_c * quality_frac)))))
@
\caption{Distribution of non-missing values for all peptides.  Peptides with non-missing values over the cutoff are shown in orange}
\label{nonmissingvals}
\end{figure}


<<mvmat, dependson = "EMsetup", cache = TRUE>>=

#look at structure in the missing values
binPepMatrix <- ifelse(is.finite(lightIC), 1, 0)

pnonmissingOverSingles <- matrix(NA, ncol = length(binPepMatrix[1,]), nrow = length(binPepMatrix[1,]))
rownames(pnonmissingOverSingles) <- colnames(binPepMatrix); colnames(pnonmissingOverSingles) <- colnames(binPepMatrix)
pnonmissingOverTotal <- pnonmissingOverSingles
for(i in 1:length(pnonmissingOverSingles[1,])){
	for(j in 1:length(pnonmissingOverSingles[1,])){	
	pnonmissingOverTotal[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2)/length(binPepMatrix[,1])
  	pnonmissingOverSingles[i,j] <- sum(apply(binPepMatrix[,c(i, j)], 1, sum) == 2) / sum(apply(binPepMatrix[,c(i, j)], 1, sum) > 0)
	}
}

@

<<missingOverlap1, dependson = "mvmat", label = "missingOverlap1", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverTotal, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2red(100), dendrogram = "none")
@

<<missingOverlap2, dependson = "mvmat", label = "missingOverlap2", echo = FALSE, include = FALSE>>=
heatmap.2(pnonmissingOverSingles, Colv = FALSE, Rowv = FALSE, trace = "none", col = blue2red(100), dendrogram = "none")
@

\begin{figure}[h!]
\begin{center}
\subfloat[p(A $\cap$ B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap1}
}
\qquad
\subfloat[A $\cap$ B / max(A, B)]{
\includegraphics[width=0.4\textwidth]{figure/missingOverlap2.pdf}}
\end{center}
\label{repFitSD2}
\caption{Overlap of missing ascertained peptides across conditions}
\end{figure}

\begin{figure}
<<>>=
plot(apply(is.na(lightIC), 2, sum) ~ c(apply(lightIC, 2, sum, na.rm = TRUE) + apply(heavyIC, 2, sum, na.rm = TRUE)), col = rep(c("RED", "ORANGE", "GREEN"), each = 5), pch = 16)
@
\caption{Number of missing peptide values for an experiment versus limitation and TIC}
\end{figure}


<<mvmat_red, dependson = "mvmat">>=
uq_ProtPepMatrix <- ProtPepMatrix[rowSums(ProtPepMatrix) == 1,]
uq_binPepMatrix <- binPepMatrix[rowSums(ProtPepMatrix) == 1,]

cond_peps <- t(((t(uq_binPepMatrix) %*% uq_ProtPepMatrix) != 0)*1)
cond_peps <- cond_peps[!(rowSums(cond_peps) %in% c(0, length(cond_peps[1,]))),]

@





\begin{figure}[h!]
<<misval_HM, dependson = "mvmat_red", echo = FALSE, warning = FALSE>>=
man_dist <- function(x){dist(x, method = "manhattan")}
heatmap.2(cond_peps, Rowv = TRUE, Colv = FALSE, trace = "none", col=blackOrange(100), distfun = man_dist, cexRow = 0.1)
@
\caption{hierarchical clustering of proteins missing in a subset of conditions using manhattan distance}
\end{figure}

<<cluster_misval, dependson = "mvmat_red", cache = TRUE>>=
	
k_clust_misVal <- 5

mv_clust <- stepFlexclust(cond_peps, k = k_clust_misVal, nrep=100, verbose=FALSE, FUN = kcca, family = kccaFamily(which = 'kmedians'))

clust_counts1 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)
clust_counts0 <- matrix(NA, nrow = k_clust_misVal, ncol = n_c)

for(kval in 1:k_clust_misVal){
	binsub <- cond_peps[mv_clust@cluster == kval,]
	clust_counts1[kval,] <- colSums(binsub)
	clust_counts0[kval,] <- length(binsub[,1]) - colSums(binsub)
	}
clust_ypos_adj <- matrix(5*rep(0:(k_clust_misVal-1), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_xpos <- matrix(rep(1:n_c, times = k_clust_misVal), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)
clust_num <- matrix(rep(1:(k_clust_misVal), each = n_c), nrow = k_clust_misVal, ncol = n_c, byrow = TRUE)

clust_plot_df <- data.frame(condition = c(c(clust_xpos), c(clust_xpos)), cluster_val = c(c(1 + clust_ypos_adj), c(clust_ypos_adj)),counts = c(c(clust_counts1), c(clust_counts0)), shape = as.factor(c(c(clust_num), c(clust_num))), medianoid = as.factor(c(c(mv_clust@centers), c(1 - mv_clust@centers))))

@

\begin{figure}[h!]
<<plot_missingvalClusters, dependson = "cluster_misval", echo = FALSE>>=
clust_plot <- ggplot(clust_plot_df, aes(x = condition, y = cluster_val, size = counts, color = medianoid))
clust_plot <- clust_plot + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
clust_plot + geom_point()
@
\end{figure}

<<GSEA_prep, cache = TRUE>>=
library(GSEABase)
library(org.Sc.sgd.db)

frame = toTable(org.Sc.sgdGO)

goframeData = data.frame(frame$go_id, frame$Evidence, frame$systematic_name)
goFrame=GOFrame(goframeData,organism="Saccharomyces cerevisiae")
goAllFrame=GOAllFrame(goFrame)
gsc <- GeneSetCollection(goAllFrame, setType = GOCollection())
@

<<perform_GSEA, dependson= c("GSEA_prep", "cluster_misval"), cache = TRUE>>=
library(methods)
library(GOstats)
library(GSEABase)
FDR = .05

#MF - molecular function, BP - biological process, CC cellular component
GSEA.test = function(genes, category) {
	universe = rownames(cond_peps)
	
	params <- GSEAGOHyperGParams(name="GSEA for Bar-Seq data",
		geneSetCollection=gsc,
		geneIds = genes,
		universeGeneIds = universe,
		ontology = category,
		pvalueCutoff = 1,
		conditional = FALSE,
		testDirection = "over")
	hyperGTest(params)
	}

sum_table <- NULL
for(kval in 1:k_clust_misVal){
	test <- names(mv_clust@cluster[mv_clust@cluster == kval])
	for(ont in c("MF", "BP", "CC")){
		go_sum <- summary(GSEA.test(test, ont))
		lowp <- go_sum[go_sum$Pvalue < 0.001,]
		if(length(lowp[,1]) != 0){
			colnames(lowp)[1] <- "GOID"
			sum_table <- rbind(sum_table, cbind(k = kval, category = ont, lowp))
			}
		}
	}
@

<<GSEAtable, dependson = "perform_GSEA", results = "asis", echo = FALSE>>=
library(xtable)
xtable(sum_table, digits = 5)
@


\clearpage
\normalsize
\section*{Going from peptides to proteins via expectation-maximization}

When using relative variation in peptides to predict variation in protein abundance we need to deal with two factors
\begin{itemize}
\item If a peptide maps to multiple proteins, it should be attributed to a protein (thereby adding signal) to the extent that its pattern matches the pattern from other peptides.
\item Some peptides won't conform to the trends of their protein because they may be the non-covalently modified complement of a set of unascertained modified peptides.  These peptides shouldn't inform the general protein trend, and may be interesting to analyze in isolation.
\end{itemize}

\subsection*{Algorithm structure}

\begin{itemize}
\item[\textbf{X}:] [I $\cdot$ C] Data matrix: Input MS data of the relative abundance of each peptide across C conditions
\item[\textbf{M}:] [I $\cdot$ J] Possible mappings between peptides (I) and proteins (J)
\item[$\mathbf{\Theta}$:] [I $\cdot$ K] Responsibility matrix: prob that peptide i belongs to protein j or shows a divergent trend which should be described separately.  K = I + J
\item[$\mathbf{\Omega}$:] [K $\cdot$ C] Point estimate for each species$\cdot$condition.
\item[$\sigma^{2}$:] [I] Fitted variance relative to peptide IC.
\end{itemize}

\begin{align}
p(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &\propto \prod_{i}^{I}\prod_{c}^{C} \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i}) \cdot \mathbf{\Theta}p(\mathbf{\Theta})\notag\\
\textit{l}(\mathbf{\Omega}, \mathbf{\Theta} | \sigma^{2}, \textbf{X}, \textbf{M}) &= \sum_{i}^{I}\sum_{c}^{C} \textit{ln}\left( \mbox{\Large \textbf{N}}(\sum_{k}^{K} \mathbf{\Theta}_{iK}\mathbf{\Omega}_{Kc} ; \textbf{X}_{ic}, \sigma^{2}_{i})\right)\notag\\
+ \sum_{i}^{I}\sum_{k}^{K}\mathbf{\Theta_{ik}}p(\mathbf{\Theta_{ik}})
\end{align}


\subsection{Updating $\mathbf{\Theta}$}

\begin{align}
\mathbf{\Theta}_{ik} \sim \frac{\textbf{N}(\mathbf{\Omega}_{kC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ik})}{\sum_{b = 1}^{K}\textbf{N}(\mathbf{\Omega}_{bC}; \textbf{X}_{iC}, \sigma^{2}_{i})\cdot p(\mathbf{\Theta}_{ib})}
\end{align}

\subsection{Updating $\mathbf{\Omega}$}

$\tau_{y} = \prod_{z \neq y}^{Y}\sigma^{2}_{z}$

\begin{align}
\mathbf{\Omega}_{kc} \sim \mbox{\Large \textbf{N}}\left(\mu = \frac{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\textbf{X}_{ic}\tau_{i}}{\sum_{i = 1}^{I}\mathbf{\Theta}_{ik}\tau_{i}}, \sigma^{2} =  \left(\sum_{i = 1}^{I}\frac{\mathbf{\Theta}_{ik}}{\sigma^{2}_{i}}\right)^{-1} \right)
\end{align}

\subsubsection*{Notes}

\begin{itemize}
\item For every protein that only has peptides that are shared by other proteins, there is little evidence that this protein exists unless the shared peptides exhibit a trend that diverges from the behavior of the shared proteins (as determined by its unique peptides).  
\end{itemize}



\subsection*{Algorithm Implementation}

\scriptsize

<<EMprep>>=	
			
### Iteration ###

prerun_fixed_mat <- TRUE

### Initalization ###

prior_bound <- 0.9999
prior_p_div <- exp(-1*qchisq(prior_bound, n_c))

#if a putative protein only has component peptides which are matched to other proteins than penalize any assignment to it by the supremum of the mixing fraction

#number of shared peptides per protein
pepshared <- colSums(unique_mappingMat[c(1:n_p)[rowSums(unique_mappingMat) > 1],])
#total peptides per protein
peptotal <- colSums(unique_mappingMat)
ambigprots <- c(1:n_prot)[pepshared == peptotal]

if((unq_matches_only == TRUE & file.exists("EMoutputUnq.Rdata"))|(unq_matches_only == FALSE & file.exists("EMoutputDeg.Rdata"))){
	if(unq_matches_only == TRUE){
		load("EMoutputUnq.Rdata")
			}else{
			load("EMoutputDeg.Rdata")
			}
	}else{
	save(unq_matches_only, prerun_fixed_mat, prior_p_div, uniquePepMean, uniquePepPrecision, unique_pepNames, unique_mappingMat, n_p, n_pp, n_prot, n_c, ambigprots, file = "EMimport.Rdata")
	#system("R64 callEM.R")

	}
n_prot <- length(prot_abund_final[1,])	
@

After carrying out EM, \Sexpr{n_prot_nonmatched} proteins were discarded because they overlapped ascertained proteins and had no strong solitary evidence of being present.  This leaves\Sexpr{n_prot} proteins for further analysis.  


\begin{figure}
<<pepResp, echo = FALSE>>=
#how many peptides are informing a protein trend, with only the largest effect considered
barplot(table(table(max_state[max_state <= n_prot])))
@
\caption{Number of peptides that are informing a protein trend, with only the largest effect considered}
\end{figure}

<<results = "asis", echo = FALSE, >>=
library(xtable)
xtable(table(div_max), caption = "Number of peptides not-conforming to some general protein trend")
@

\begin{figure}
<<EMlikplot, echo = FALSE>>=
plot(whole_data_logL[-1], col = ifelse(c(2:length(whole_data_logL)) <= initial_convergence, "ORANGE", "BLACK"), pch = 16)
@
\caption{Log-likelihood of EM.  First stage (black) allows for a peptide to partially match proteins and partially diverge from the trend, the second stage (orange) thresholds such that a peptide is entirely accounted for by protein trends or entirely departs from plausible trends}
\end{figure}

\begin{figure}
<<rawHM, echo = FALSE>>=
heatmap.2(t(prot_abund_final), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(prot_abund_final, na.rm = TRUE)), max(range(prot_abund_final, na.rm = TRUE)), by = max(range(prot_abund_final, na.rm = TRUE))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM}
\end{figure}

<<MVimputeCompare, dependson = "EMrun", cache = TRUE>>=
library(missMDA)
#determine how many significant principal components should be included based on repeated random sub-sampling validation
pcrange <- c(2,12)
npc.compare <- estim_ncpPCA(prot_abund_final, ncp.min = pcrange[1], ncp.max = pcrange[2], method.cv = 'Kfold', pNA = 0.10, nbsim = 50)

npc <- (pcrange[1]:pcrange[2])[npc.compare$criterion < (max(npc.compare$criterion) - min(npc.compare$criterion))*0.01 + min(npc.compare$criterion)][1]

@

<<MVimputeData, dependson = "MVimputeCompare", cache = TRUE>>=
#determine the most likely values of the missing data
impute_abund <- imputePCA(prot_abund_final, npc, scale = FALSE)$completeObs
impute_abund_thresh <- impute_abund
impute_abund_thresh[impute_abund_thresh > 5] <- 5; impute_abund_thresh[impute_abund_thresh < -5] <- -5
@

%<<>>=
%save(impute_abund_thresh, "tmp.Rdata")
%@

\begin{figure}
<<mvNpc, echo = FALSE>>=
plot(npc.compare$criterion ~ c(pcrange[1]:pcrange[2]), pch = 16, ylab = "MS error of prediction", xlab = "number of PCs")
abline(v = npc, col = "RED", lwd = 2)
save(impute_abund_thresh, file = "tmp.Rdata")
@
\caption{Reconstruction error of raw matrix using PC-based imputation}
\end{figure}

\begin{figure}
<<impHM, echo = FALSE>>=
heatmap.2(t(impute_abund_thresh), trace = "none", Colv = NULL, dendrogram = "row", na.color = "white", col = greenred(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "white", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\caption{Relative protein abundance across \Sexpr{n_c} conditions, after running EM and imputing missing values with missMDA}
\end{figure}

\begin{figure}
<<>>=
library(reshape)

impSVD_pcs <- svd(t(impute_abund_thresh), nu = npc, nv = npc)$v
colnames(impSVD_pcs) <- paste("PC", c(1:npc), "")

pc_plot_df <- melt(impSVD_pcs)
colnames(pc_plot_df) <- c("condition", "PC", "value")

factor_plot <- ggplot(pc_plot_df, aes(x = condition, y = value, col = factor(PC)))
print(factor_plot + geom_line())
@
\end{figure}



<<plot_proteinTrends, dependson = "MVimputeData", cache = TRUE, warning = FALSE>>=
tmp <- Matrix(diag(rep(prior_p_div, times = n_p))); colnames(tmp) <- paste(unique_pepNames, "divergent", sep = "_")
tmp <- as.matrix(tmp)
tmp[!(tmp %in% c(0,1))] <- 1 
prior_mat_logical <- cbind(as.matrix(unique_mappingMat), tmp) 
prior_mat_logical <- prior_mat_logical == 1
possibleMap <- Matrix(prior_mat_logical)
@

<<>>=
plot_protein_lattice(c(1:10), possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, 2)
@


<<>>=
plot_protein_lattice(c(11:35), possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, 5)
@

<<>>=
plot_protein_lattice(c(36:60), possibleMap, prot_abund_final, prot_prec, uniquePepMean, uniquePepPrecision, mixing_fract, 5)
@








Determine the abundance of transcripts corresponding to ascertained proteins

<<ModifyTransc, dependson = "MVimputeData">>=
library("missMDA")

transcript_brauer <- read.delim("../brauer-microarray/Brauer_2008.pcl")
rownames(transcript_brauer) <- transcript_brauer$SYSTEMATIC_NAME
transcript_brauer <- transcript_brauer[-1,-c(1:3)]

transcript.condition <- as.data.frame(matrix(NA, ncol = 36, nrow = 2))
colnames(transcript.condition) <- colnames(transcript_brauer)
rownames(transcript.condition) <- c("limitation", "GR")
limitations <- c("C", "N", "P", "S", "L", "U")
transcript.condition[1,] <- rep(limitations, each = 6)
transcript.condition[2,] <- rep(c(0.05, 0.10, 0.15, 0.20, 0.25, 0.30), times = 6)

#barplot(table(rowSums(is.na(transcript_brauer))))

#filter genes with many missing values
transcript_brauer <- transcript_brauer[rowSums(is.na(transcript_brauer)) < length(transcript.condition[1,])*0.2,]

npc.trans <- 10

#impute missing values (very few)

transcript_brauer_impute <- imputePCA(transcript_brauer, npc, scale = FALSE)$completeObs

#missing mappings
missing_on_array <- colnames(impute_abund_thresh)[!(colnames(impute_abund_thresh) %in% rownames(transcript_brauer_impute))]
length(missing_on_array)
genes_to_compare <- colnames(impute_abund)[colnames(impute_abund) %in% rownames(transcript_brauer_impute)]

#determine the relative abundance of array data by looking at the corresponding condition and imputing unobserved growth rates by drawing a line between the abundance of flanking conditions

tmp <- sapply(genes_to_compare, function(match){
	transcript_brauer_impute[rownames(transcript_brauer_impute) == match,]
	})
transcript_brauer_reduced <- matrix(unlist(tmp), ncol = length(tmp[1,]), nrow = length(tmp[,1]))
colnames(transcript_brauer_reduced) <- colnames(tmp); rownames(transcript_brauer_reduced) <- rownames(tmp)


#load true dilution rates for each of the proteomics samples
load('~/Desktop/Composition/RNA_abundance/RNAabundance.R')

prot_cond <- as.data.frame(matrix(NA, ncol = n_c, nrow = 2))
prot_cond <- sapply(rownames(impute_abund), function(cond){
	c(unlist(strsplit(cond, '[0-9]+'))[1], unlist(strsplit(cond, '[A-Z]'))[2])
	})
colnames(prot_cond) <- rownames(impute_abund)
rownames(prot_cond) <- c("limitation", "GR")
prot_cond <- as.data.frame(cbind(t(prot_cond), realDR = NA), stringsAsFactors = FALSE)
prot_cond$realDR <- sapply(1:length(prot_cond[,1]), function(cond){
	RNAabund$actual.dr[grep(paste(prot_cond$limitation[cond], prot_cond$GR[cond], sep = ""), RNAabund$condition, ignore.case = TRUE)[1]]
	})

DR_change_mat <- matrix(0, nrow = length(transcript.condition[1,]), ncol = length(prot_cond[,1]))
colnames(DR_change_mat) <- rownames(prot_cond); rownames(DR_change_mat) <- colnames(transcript.condition)
for(cond in 1:length(prot_cond[,1])){
	#find the 2 closest DR within the same limitation
	c_match <- c(1:length(transcript.condition[1,]))[transcript.condition[1,] %in% prot_cond[cond,]$limitation]
	flanking_match <- c_match[order(abs(as.numeric(transcript.condition[2,c_match]) - prot_cond[cond,]$realDR))[1:2]]
	lb_diff <- (prot_cond$realDR[cond] - as.numeric(transcript.condition[2,flanking_match])[1])/diff(as.numeric(transcript.condition[2,flanking_match]))
	DR_change_mat[flanking_match,cond] <- c((1-lb_diff), lb_diff)
	}
	
remapped_transc <- t(transcript_brauer_reduced) %*% DR_change_mat
@

\begin{figure}
<<transHM, dependson = "ModifyTransc", echo = FALSE>>=
heatmap.2(remapped_transc, trace = "none", Colv = NULL, dendrogram = "row", na.rm = TRUE, na.color = "white", col = greenBlackRed(500), labRow = FALSE, symkey = TRUE, scale = "none", denscol = "black", breaks = seq(-1*max(range(impute_abund)), max(range(impute_abund)), by = max(range(impute_abund))/250))
@
\label{Hierarchical clustering of interpolated transcript values of transcripts corresponding to ascertained proteins}
\end{figure}

<<PTcor, dependson = "ModifyTransc", cache = TRUE>>=
#measure the correlation of the transcript and protein matrix

shared_prot <- impute_abund[,(colnames(impute_abund) %in% rownames(transcript_brauer))] 
shared_trans <- t(remapped_transc)

#center each sample #remove when normalization factor is known
shared_prot <- shared_prot - t(t(apply(shared_prot, 1, mean))) %*% t(rep(1, times = length(shared_prot[1,])))
shared_trans <- shared_trans - t(t(apply(shared_trans, 1, mean))) %*% t(rep(1, times = length(shared_trans[1,])))

pt_corrs <- sapply(c(1:length(shared_prot[1,])), function(row){
	cor(shared_prot[,row], shared_trans[,row], method = "spearman")
	}); pt_corrs <- data.frame(correlation = pt_corrs)

save(shared_prot, shared_trans, file = "shared_prot_trans.Rdata")

@

\begin{figure}
<<echo = FALSE>>=
gplot.hexbin(hexbin(x = shared_prot, y = shared_trans, xbins = 50), colramp = blue2red, xlab = "Protein Abundance", ylab = "Transcript Abundance")
@
\caption{No global correlation between relative protein abundance and relative transcript abundance}
\end{figure}


\begin{figure}
<<echo = FALSE>>=
cor_plot <- ggplot(pt_corrs, aes(x = correlation))
cor_plot + xlab("spearman correlation") + geom_histogram(colour = "white", fill = "limegreen", binwidth = 0.04)
@
\caption{Distribution of spearman correlations across transcript-protein pairs}
\end{figure}

<<fileDump1, dependson = "c(mvmat_red, mv_impute)", echo = FALSE>>=
#file dump
#add gene descriptions
rownames(cond_peps) <- orf2desc(rownames(cond_peps))
impute_abund_thresh_store <- impute_abund_thresh
colnames(impute_abund_thresh_store) <- orf2desc(colnames(impute_abund_thresh_store))

#save(cond_peps, impute_abund_thresh, file = "protMatrices.Rdata")
if(unq_matches_only == TRUE){
write.table(cond_peps, file = "run_Unq/mvMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(impute_abund_thresh_store), file = "run_Unq/relAbundMatrix_desc.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(impute_abund_thresh), file = "run_Unq/relAbundMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(shared_prot - shared_trans), file = "run_Unq/TPdiffMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
}
if(unq_matches_only == FALSE){
write.table(cond_peps, file = "run_Deg/mvMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(impute_abund_thresh_store), file = "run_Deg/relAbundMatrix_desc.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(impute_abund_thresh), file = "run_Deg/relAbundMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(t(shared_prot - shared_trans), file = "run_Deg/TPdiffMatrix.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
}
@

Determine how many clusters should be used for K-means clustering of protein abundance \& protein - transcript difference matrices.
<<kmeansNclust, dependson = "transHM", cache = TRUE>>=

kvals <- c(2:30)
data_clust <- stepFlexclust(t(impute_abund_thresh), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_prot <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})
	
data_clust <- stepFlexclust(t(shared_prot - shared_trans), k = kvals, nrep=10, verbose=FALSE, FUN = kcca)

WICSS_pt <- sapply(1:length(kvals), function(k_num){
	cSS <- apply(getModel(data_clust, which = k_num)@cldist, 2, sum)
	cSS[1] * length(cond_peps[,1])/(length(cond_peps[,1]) - kvals[k_num])
	})	
	
@

<<kmeanBarplot, dependson = "kmeansNclust", warning = FALSE, echo = FALSE>>=
plot_df <- data.frame(WICSSdiff = c(-1*diff(WICSS_prot), -1*diff(WICSS_pt)), nclusters = rep(kvals[-length(kvals)], times = 2), class = rep(c("Protein Abundance", "Protein - Transcript Abundance"), each = (length(kvals) - 1)))

clusterN_plot <- ggplot(plot_df, aes(x = nclusters, y = WICSSdiff)) + facet_grid(class ~ ., scales = "free_y")
clusterN_plot + geom_bar(stat = "identity")
@


Read in cluster assignments from Cluster2.0

<<prot_clust>>=

if(unq_matches_only == TRUE){
	prot_kmeans_ass <- read.delim("run_Unq/relAbundMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	prot_kmeans_ass <- read.delim("run_Deg/relAbundMatrix_K_G20.kgg")
	}

clusteredDat <- t(impute_abund_thresh)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(prot_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), prot_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}
	
nclust <- length(unique(prot_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% prot_kmeans_ass[,1][prot_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	prot_kmeans_ass$GROUP[prot_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}
<<protclustplot, dependson = "prot_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins in a cluster (teal) and the centroid itself (orange)}
\end{figure}

<<tn_clust>>=

if(unq_matches_only == TRUE){
	pt_kmeans_ass <- read.delim("run_Unq/TPdiffMatrix_K_G20.kgg")
	}
if(unq_matches_only == FALSE){
	pt_kmeans_ass <- read.delim("run_Deg/TPdiffMatrix_K_G20.kgg")
	}

clusteredDat <- t(shared_prot - shared_trans)
#make sure that this data has the same gene names as the clustered data

if(!(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(pt_kmeans_ass[,1])) | !(length(union(rownames(clusteredDat), pt_kmeans_ass[,1])) == length(clusteredDat[,1]))){
	print("mismatched clusters")
	}

nclust <- length(unique(pt_kmeans_ass$GROUP))
Centroids <- matrix(NA, ncol = n_c, nrow = nclust)

for(clust in 0:(nclust-1)){
	Centroids[clust+1,] <- apply(clusteredDat[rownames(clusteredDat) %in% pt_kmeans_ass[,1][pt_kmeans_ass$GROUP == clust],], 2, mean)
	}

gene_cluster <- sapply(rownames(clusteredDat), function(gene){
	pt_kmeans_ass$GROUP[pt_kmeans_ass[,1] == gene]
	})

clust_yval <- rbind(clusteredDat, Centroids)
clust_xval <- t(t(rep(1, times = length(clust_yval[,1])))) %*% t(rep(1:n_c, times = 1))
clust_num <- t(t(c(gene_cluster, 0:(nclust-1)))) %*% t(rep(1, times = n_c))
centroid_size_adj <- t(t(c(rep(1, times = length(clusteredDat[,1])), rep(4, times = nclust)))) %*% t(rep(1, times = n_c))
clust_datatype <- centroid_size_adj; clust_datatype[clust_datatype == 1] <- "Protein"; clust_datatype[clust_datatype == 4] <- "Centroid"

clust_plot_df <- data.frame(condition = c(clust_xval), abundance = c(clust_yval), cluster = c(clust_num), dataType = as.factor(c(clust_datatype)), clustersize = c(centroid_size_adj))

@

\begin{figure}
<<tnclustplot, dependson = "tn_clust", echo = FALSE>>=
clust_plotterer <- ggplot(clust_plot_df, aes(x = condition, y = abundance, colour = dataType, size = clustersize)) + facet_wrap( ~ cluster, ncol = 4) + scale_area(range = c(1,2), guide = "none") + scale_colour_discrete(guide = "none")
clust_plotterer + geom_point()
@
\caption{Trace of proteins - transcript differences; clusters (teal) and the centroid itself (orange)}
\end{figure}



\end{document}  
